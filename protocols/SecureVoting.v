(* DISTRIBUTION STATEMENT A. Approved for public release. Distribution is unlimited.
 *
 * This material is based upon work supported by the Department of the Air Force under Air Force 
 * Contract No. FA8702-15-D-0001. Any opinions, findings, conclusions or recommendations expressed 
 * in this material are those of the author(s) and do not necessarily reflect the views of the 
 * Department of the Air Force.
 * 
 * Â© 2020 Massachusetts Institute of Technology.
 * 
 * MIT Proprietary, Subject to FAR52.227-11 Patent Rights - Ownership by the contractor (May 2014)
 * 
 * The software/firmware is provided to you on an As-Is basis
 * 
 * Delivered to the U.S. Government with Unlimited Rights, as defined in DFARS Part 252.227-7013
 * or 7014 (Feb 2014). Notwithstanding any copyright notice, U.S. Government rights in this work are
 * defined by DFARS 252.227-7013 or DFARS 252.227-7014 as detailed above. Use of this work other than
 * as specifically authorized by the U.S. Government may violate any copyrights that exist in this work. *)
From Coq Require Import
     List.

Require Import
        MyPrelude
        Maps
        ChMaps
        Messages
        ModelCheck
        Common
        Keys
        Automation
        Tactics
        Simulation
        AdversaryUniverse
        UniverseEqAutomation
        ProtocolAutomation
        SafeProtocol
        ProtocolFunctions.

Require IdealWorld RealWorld.

Import IdealWorld.IdealNotations
       RealWorld.RealWorldNotations
       SimulationAutomation.

Import Sets.
Module Foo <: EMPTY.
End Foo.
Module Import SN := SetNotations(Foo).

Set Implicit Arguments.

Open Scope protocol_scope.

Module VotingProtocol.

  (* Start with two users, as that is the minimum for any interesting protocol *)
  Notation USR1 := 0.
  Notation USR2 := 1.
  Notation USR3 := 2.

  Section IW.
    Import IdealWorld.

    (* Set up initial communication channels so each user can talk directly to the other *)
    Notation pCH13 := 0.
    Notation pCH23 := 1.
    Notation CH13  := (# pCH13).
    Notation CH23  := (# pCH23).

    (* This is the initial channel vector, each channel should be represented and start with 
     * no messages.
     *)
    Notation empty_chs := (#0 #+ (CH13, []) #+ (CH23, [])).

    Notation PERMS1 := ($0 $+ (pCH13, writer)).
    Notation PERMS2 := ($0 $+ (pCH23, writer)).
    Notation PERMS3 := ($0 $+ (pCH13, reader) $+ (pCH23, reader)).

    (* Fill in the users' protocol specifications here, adding additional users as needed.
     * Note that all users must return an element of the same type, and that type needs to 
     * be one of: ...
     *)
    Notation ideal_users :=
      [
        mkiUsr USR1 PERMS1
               ( _ <- Send (Content 1) CH13
                 ; @Return (Base Nat) 1
               )
        ; 

      mkiUsr USR2 PERMS2
             ( _ <- Send (Content 1) CH23
               ; @Return (Base Nat) 1
             )
        ; 

      mkiUsr USR3 PERMS3
             ( m1 <- @Recv Nat CH13
               ; m2 <- @Recv Nat CH23
               ; @Return (Base Nat) (let c1 := extractContent m1 in
                                     let c2 := extractContent m2
                                     in if c1 ==n c2 then c1 else 100)
             )
      ].

    (* This is where the entire specification universe gets assembled.  It is unlikely anything
     * will need to change here.
     *)
    Definition ideal_univ_start :=
      mkiU empty_chs ideal_users.

  End IW.

  Section RW.
    Import RealWorld.
    Import RealWorld.message.

    (* Key management needs to be bootstrapped.  Since all honest users must only send signed
     * messages, we need some way of initially distributing signing keys in order to be able
     * to begin secure communication.  This is analagous in the real world where we need to 
     * have some sort of trust relationship in order to distribute trusted keys.
     * 
     * Here, each user has a public asymmetric signing key.
     *)
    Notation KID1 := 0.
    Notation KID2 := 1.
    Notation KID3 := 3.

    Notation KEYS := [ skey KID1 ; skey KID2 ; ekey KID3 ].

    Notation KEYS1 := ($0 $+ (KID1, true) $+ (KID3, false)).
    Notation KEYS2 := ($0 $+ (KID2, true) $+ (KID3, false)).
    Notation KEYS3 := ($0 $+ (KID1, false) $+ (KID2, false) $+ (KID3, true)).

    Notation real_users :=
      [
        (* User 1 implementation *)
        MkRUserSpec USR1 KEYS1
                    (
                      c <- SignEncrypt KID1 KID3 USR3 (Content 1)
                      ; _ <- Send USR3 c
                      ; ret 1
                    )
        ; 

      (* User 2 implementation *)
      MkRUserSpec USR2 KEYS2
                  (
                    c <- SignEncrypt KID2 KID3 USR3 (Content 1)
                    ; _ <- Send USR3 c
                    ; ret 1
                  )
        ; 

      (* User 2 implementation *)
      MkRUserSpec USR3 KEYS3
                  (
                    voteC1 <- @Recv Nat (SignedEncrypted KID1 KID3 true)
                    ; voteC2 <- @Recv Nat (SignedEncrypted KID2 KID3 true)
                    ; vote1 <- Decrypt voteC1
                    ; vote2 <- Decrypt voteC2
                    ; ret (let v1 := extractContent vote1 in
                           let v2 := extractContent vote2
                           in  if v1 ==n v2 then v1 else 100)
                  )
      ].

    (* Here is where we put the implementation universe together.  Like above, it is 
     * unlikely anything will need to change here.
     *)
    Definition real_univ_start :=
      mkrU (mkKeys KEYS) real_users.
  End RW.

  (* These are here to help the proof automation.  Don't change. *)
  Hint Unfold
       real_univ_start
       ideal_univ_start
    : user_build.

  Hint Extern 0 (IdealWorld.lstep_universe _ _ _) =>
    progress(autounfold with user_build; simpl).
  
End VotingProtocol.

Module VotingProtocolSecure <: AutomatedSafeProtocol.

  Import VotingProtocol.

  (* Some things may need to change here.  t__hon is where we place the 
   * type that the protocol computes.  It is set to Nat now, because we
   * return a natual number.
   *)
  Definition t__hon := Nat.
  Definition t__adv := Unit.
  Definition b    := tt.

  (* These two variables hook up the starting points for both specification and
   * implementation universes.  If you followed the template above, this shouldn't
   * need to be changed.
   *)
  Definition iu0  := ideal_univ_start.
  Definition ru0  := real_univ_start.

  Import Gen Tacs SetLemmas.

  (* These are here to help the proof automation.  Don't change. *)
  Hint Unfold t__hon t__adv b ru0 iu0 ideal_univ_start real_univ_start : core.
  Hint Unfold
       mkiU mkiUsr mkrU mkrUsr
       mkKeys
    : core.

  Lemma safe_invariant :
    invariantFor
      {| Initial := {(ru0, iu0, true)}; Step := @step t__hon t__adv  |}
      (fun st => safety st /\ alignment st ).
  Proof.
    eapply invariant_weaken.

    - eapply multiStepClosure_ok; simpl.
      (* Calls to gen1 will need to be addded here until the model checking terminates. *)
      gen1.
      gen1.
      gen1.
      gen1.

      match goal with
      | [|- multiStepClosure _ (_ \cup ?wl) ?wl _] =>
        idtac wl
      end.

      Ltac normalize_set_arg s :=
        match s with
        | context[@union ?A ?X ?Y] =>
          quote (@union A X Y) (@nil A)
                ltac:(fun e env =>
                        change (@union A X Y) with (interp_setexpr env e));
          rewrite <- normalize_setexpr_ok; sets_cbv
        end.

      match goal with
      | [|- multiStepClosure _ (_ \cup ?wl) ?wl _] =>
        progress (normalize_set_arg wl)
      end.
      match goal with
      | [|- multiStepClosure _ (_ \cup ?wl) ?wl _] =>
        idtac wl
      end.

      eapply msc_step_alt.
      + unfold oneStepClosure_new; repeat gen1'.
      + simplify.
        progress (simpl_sets (sets; tidy)).
        sets.

      
      gen1.
      gen1.
      gen1.
      gen1.
      gen1.

      gen1.
      gen1.
      gen1.

      eapply msc_step_alt.
      + unfold oneStepClosure_new; repeat gen1'.
      + simplify.
        sets.

        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.
        split_ex; repeat univ_equality_discr.

        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-100: split_ex; repeat univ_equality_discr.
        1-200: try solve [ split_ex; repeat univ_equality_discr ].

        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.

        
        split_ex.
        univ_equality_discr.
        univ_equality_discr.
        univ_equality_discr.

        Ltac clear_eq := 
          repeat match goal with
                 | [ H : ?x = ?x |- _ ] => clear H
                 end.

        clear_eq.
        univ_equality_discr.
        simpl in *.
        clear_eq.
        univ_equality_discr.
        clear_eq.
        univ_equality_discr.
        clear_eq.
        
        Ltac process_rmv :=
          repeat match goal with
                 | [ H : context [ _ $+ (?k1,_) $- ?k2 ] |- _ ] =>
                   (rewrite map_add_remove_eq in H by trivial)
                   || (rewrite map_add_remove_neq in H by eauto)
                   || (rewrite remove_not_in_map_idempotent in H by eauto)
                 end.

        Import RealWorld.

        apply map_eq_fields_eq in H1.
        split_ex.
        rewrite add_eq_o in H1 by trivial.
        apply some_eq_inv in H1.
        univ_equality_discr.
        clear_eq.
        repeat equality1.
        clear_eq.
        clean_map_lookups.

        process_rmv.
        clear_eq.



    discriminate
    || match goal with
      | [ H1 : ?x = ?y1, H2 : ?x = ?y2 |- _ ] =>
        rewrite H1 in H2
        ; clear H1
      | [ H1 : ?x = ?y1, H2 : ?y2 = ?x |- _ ] =>
        rewrite H1 in H2
        ; clear H1
      | [ H : (?x1,?y1) = (?x2,?y2) |- _ ] =>
        apply tuple_eq_inv in H; split_ex; subst
      | [ H : {| users := _ |} = {| users := _ |} |- _ ] =>
        apply split_real_univ_fields in H; split_ex
      | [ H : Some _ = Some _ |- _ ] =>
        apply some_eq_inv in H; subst
      | [ H : {| key_heap := _ |} = {| key_heap := _ |} |- _ ] =>
        apply split_real_user_data_fields in H; split_ex; subst
      | [ H : _ $+ (_,_) = _ |- _ ] =>
        apply map_eq_fields_eq in H; clean_map_lookups
      end.
        univ_equality_discr
        process_rmv.

        
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        admit.
        

          
                 ; split_ex
                 ; propositional
                 ; idtac "preparing to discriminate universes"
                 ; repeat univ_equality_discr


admit.




6 focused subgoals
(shelved: 13) (ID 5737046)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H0 : exists y y0 : Map.key,
         ((y0 = y -> False) /\ incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                      RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                        (fun vote2 : RealWorld.message.message Nat =>
                                                         RealWorld.Return
                                                           (if
                                                             RealWorld.message.extractContent vote1 ==n
                                                             RealWorld.message.extractContent vote2
                                                            then RealWorld.message.extractContent vote1
                                                            else 100)));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y; y0];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                        (# 0) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H1 : exists y y0 : Map.key,
         ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ (# 1 = # 0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                      RealWorld.Return
                                                        (if
                                                          match
                                                            RealWorld.message.extractContent vote2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e : nat =>
                                                                           match e with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e => left (f_equal_nat nat S 0 m e)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0; y];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y,
                                   RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                        (# 0) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5737082) is:
 False
subgoal 3 (ID 5737334) is:
 False
subgoal 4 (ID 5737370) is:
 False
subgoal 5 (ID 5737478) is:
 False
subgoal 6 (ID 5737586) is:
 False


7 focused subgoals
(shelved: 13) (ID 5736866)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H0 : exists y y0 : Map.key,
         ((y = y0 -> False) /\ incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (# 1 = # 0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                      RealWorld.Return
                                                        (if
                                                          match
                                                            RealWorld.message.extractContent vote2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e : nat =>
                                                                           match e with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e => left (f_equal_nat nat S 0 m e)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0; y];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                        (# 0) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H1 : exists y y0 : Map.key,
         (incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                      RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                        (fun vote2 : RealWorld.message.message Nat =>
                                                         RealWorld.Return
                                                           (if
                                                             RealWorld.message.extractContent vote1 ==n
                                                             RealWorld.message.extractContent vote2
                                                            then RealWorld.message.extractContent vote1
                                                            else 100)));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y; y0];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                   RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5737046) is:
 False
subgoal 3 (ID 5737082) is:
 False
subgoal 4 (ID 5737334) is:
 False
subgoal 5 (ID 5737370) is:
 False
subgoal 6 (ID 5737478) is:
 False
subgoal 7 (ID 5737586) is:
 False



8 focused subgoals
(shelved: 13) (ID 5736830)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H0 : exists y y0 : Map.key,
         ((y = y0 -> False) /\ incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (# 1 = # 0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                      RealWorld.Return
                                                        (if
                                                          match
                                                            RealWorld.message.extractContent vote2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e : nat =>
                                                                           match e with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e => left (f_equal_nat nat S 0 m e)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0; y];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                        (# 0) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H : exists y y0 : Map.key,
        ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
        (a0, b1, b0) =
        ({|
         RealWorld.users := $0 $+ (0,
                            {|
                            RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y0];
                            RealWorld.from_nons := [];
                            RealWorld.sent_nons := [(Some 0, 0)];
                            RealWorld.cur_nonce := 1 |}) $+ (1,
                            {|
                            RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y];
                            RealWorld.from_nons := [];
                            RealWorld.sent_nons := [(Some 1, 0)];
                            RealWorld.cur_nonce := 1 |}) $+ (2,
                            {|
                            RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                    (fun vote1 : RealWorld.message.message Nat =>
                                                     RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                       (fun vote2 : RealWorld.message.message Nat =>
                                                        RealWorld.Return
                                                          (if
                                                            RealWorld.message.extractContent vote1 ==n
                                                            RealWorld.message.extractContent vote2
                                                           then RealWorld.message.extractContent vote1
                                                           else 100)));
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y; y0];
                            RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                            RealWorld.sent_nons := [];
                            RealWorld.cur_nonce := 0 |});
         RealWorld.adversary := {|
                                RealWorld.key_heap := $0;
                                RealWorld.protocol := RealWorld.Return tt;
                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                      existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                RealWorld.c_heap := [];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [];
                                RealWorld.cur_nonce := 0 |};
         RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                  RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
        {|
        IdealWorld.channel_vector := IdealWorld.addMsg
                                       (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                       (# 0) (IdealWorld.message.Content 1);
        IdealWorld.users := $0 $+ (0,
                            {|
                            IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                            IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                            {|
                            IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                            IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                            {|
                            IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                    IdealWorld.Return
                                                      (if
                                                        match
                                                          IdealWorld.message.extractContent m2 as n
                                                          return ({1 = n} + {1 = n -> False})
                                                        with
                                                        | 0 =>
                                                            right
                                                              (fun H : 1 = 0 =>
                                                               match H in (_ = y1) return (y1 = 0 -> False) with
                                                               | eq_refl =>
                                                                   fun H0 : 1 = 0 =>
                                                                   False_ind False
                                                                     (eq_ind 1
                                                                        (fun e : nat =>
                                                                         match e with
                                                                         | 0 => False
                                                                         | S _ => True
                                                                         end) I 0 H0)
                                                               end eq_refl)
                                                        | S m =>
                                                            match
                                                              match m as n return ({0 = n} + {0 = n -> False}) with
                                                              | 0 => left eq_refl
                                                              | S m0 => right (O_S m0)
                                                              end
                                                            with
                                                            | left e => left (f_equal_nat nat S 0 m e)
                                                            | right n0 => right (not_eq_S 0 m n0)
                                                            end
                                                        end
                                                       then 1
                                                       else 100))%idealworld;
                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5736866) is:
 False
subgoal 3 (ID 5737046) is:
 False
subgoal 4 (ID 5737082) is:
 False
subgoal 5 (ID 5737334) is:
 False
subgoal 6 (ID 5737370) is:
 False
subgoal 7 (ID 5737478) is:
 False
subgoal 8 (ID 5737586) is:
 False



9 focused subgoals
(shelved: 13) (ID 5736794)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H0 : exists y y0 : Map.key,
         ((y = y0 -> False) /\ incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (# 1 = # 0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                      RealWorld.Return
                                                        (if
                                                          match
                                                            RealWorld.message.extractContent vote2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e : nat =>
                                                                           match e with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e => left (f_equal_nat nat S 0 m e)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0; y];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                        (# 0) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H : exists y y0 : Map.key,
        ((y0 = y -> False) /\ incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
        (a0, b1, b0) =
        ({|
         RealWorld.users := $0 $+ (0,
                            {|
                            RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y0];
                            RealWorld.from_nons := [];
                            RealWorld.sent_nons := [(Some 0, 0)];
                            RealWorld.cur_nonce := 1 |}) $+ (1,
                            {|
                            RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y];
                            RealWorld.from_nons := [];
                            RealWorld.sent_nons := [(Some 1, 0)];
                            RealWorld.cur_nonce := 1 |}) $+ (2,
                            {|
                            RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                    (fun vote1 : RealWorld.message.message Nat =>
                                                     RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                       (fun vote2 : RealWorld.message.message Nat =>
                                                        RealWorld.Return
                                                          (if
                                                            RealWorld.message.extractContent vote1 ==n
                                                            RealWorld.message.extractContent vote2
                                                           then RealWorld.message.extractContent vote1
                                                           else 100)));
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y; y0];
                            RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                            RealWorld.sent_nons := [];
                            RealWorld.cur_nonce := 0 |});
         RealWorld.adversary := {|
                                RealWorld.key_heap := $0;
                                RealWorld.protocol := RealWorld.Return tt;
                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                      existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                RealWorld.c_heap := [];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [];
                                RealWorld.cur_nonce := 0 |};
         RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                  RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
        {|
        IdealWorld.channel_vector := IdealWorld.addMsg
                                       (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                       (# 0) (IdealWorld.message.Content 1);
        IdealWorld.users := $0 $+ (0,
                            {|
                            IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                            IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                            {|
                            IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                            IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                            {|
                            IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                    IdealWorld.Return
                                                      (if
                                                        match
                                                          IdealWorld.message.extractContent m2 as n
                                                          return ({1 = n} + {1 = n -> False})
                                                        with
                                                        | 0 =>
                                                            right
                                                              (fun H : 1 = 0 =>
                                                               match H in (_ = y1) return (y1 = 0 -> False) with
                                                               | eq_refl =>
                                                                   fun H0 : 1 = 0 =>
                                                                   False_ind False
                                                                     (eq_ind 1
                                                                        (fun e : nat =>
                                                                         match e with
                                                                         | 0 => False
                                                                         | S _ => True
                                                                         end) I 0 H0)
                                                               end eq_refl)
                                                        | S m =>
                                                            match
                                                              match m as n return ({0 = n} + {0 = n -> False}) with
                                                              | 0 => left eq_refl
                                                              | S m0 => right (O_S m0)
                                                              end
                                                            with
                                                            | left e => left (f_equal_nat nat S 0 m e)
                                                            | right n0 => right (not_eq_S 0 m n0)
                                                            end
                                                        end
                                                       then 1
                                                       else 100))%idealworld;
                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5736830) is:
 False
subgoal 3 (ID 5736866) is:
 False
subgoal 4 (ID 5737046) is:
 False
subgoal 5 (ID 5737082) is:
 False
subgoal 6 (ID 5737334) is:
 False
subgoal 7 (ID 5737370) is:
 False
subgoal 8 (ID 5737478) is:
 False
subgoal 9 (ID 5737586) is:
 False

                 


10 focused subgoals
(shelved: 13) (ID 5736398)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H1 : exists y y0 : Map.key,
         ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                      RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                        (fun vote2 : RealWorld.message.message Nat =>
                                                         RealWorld.Return
                                                           (if
                                                             RealWorld.message.extractContent vote1 ==n
                                                             RealWorld.message.extractContent vote2
                                                            then RealWorld.message.extractContent vote1
                                                            else 100)));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y; y0];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H0 : exists y y0 : Map.key,
         (incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                      RealWorld.Return
                                                        (if
                                                          match
                                                            RealWorld.message.extractContent vote2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e : nat =>
                                                                           match e with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e => left (f_equal_nat nat S 0 m e)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0; y];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y,
                                   RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5736794) is:
 False
subgoal 3 (ID 5736830) is:
 False
subgoal 4 (ID 5736866) is:
 False
subgoal 5 (ID 5737046) is:
 False
subgoal 6 (ID 5737082) is:
 False
subgoal 7 (ID 5737334) is:
 False
subgoal 8 (ID 5737370) is:
 False
subgoal 9 (ID 5737478) is:
 False
subgoal 10 (ID 5737586) is:
 False




11 focused subgoals
(shelved: 13) (ID 5736362)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H1 : exists y y0 : Map.key,
         ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                      RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                        (fun vote2 : RealWorld.message.message Nat =>
                                                         RealWorld.Return
                                                           (if
                                                             RealWorld.message.extractContent vote1 ==n
                                                             RealWorld.message.extractContent vote2
                                                            then RealWorld.message.extractContent vote1
                                                            else 100)));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y; y0];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H : exists y y0 : Map.key,
        ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ (# 1 = # 0 -> False) /\ True) /\
        (a0, b1, b0) =
        ({|
         RealWorld.users := $0 $+ (0,
                            {|
                            RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y];
                            RealWorld.from_nons := [];
                            RealWorld.sent_nons := [(Some 0, 0)];
                            RealWorld.cur_nonce := 1 |}) $+ (1,
                            {|
                            RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y0];
                            RealWorld.from_nons := [];
                            RealWorld.sent_nons := [(Some 1, 0)];
                            RealWorld.cur_nonce := 1 |}) $+ (2,
                            {|
                            RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                    (fun vote2 : RealWorld.message.message Nat =>
                                                     RealWorld.Return
                                                       (if
                                                         match
                                                           RealWorld.message.extractContent vote2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100));
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y0; y];
                            RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                            RealWorld.sent_nons := [];
                            RealWorld.cur_nonce := 0 |});
         RealWorld.adversary := {|
                                RealWorld.key_heap := $0;
                                RealWorld.protocol := RealWorld.Return tt;
                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                      existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                RealWorld.c_heap := [];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [];
                                RealWorld.cur_nonce := 0 |};
         RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y,
                                  RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
        {|
        IdealWorld.channel_vector := IdealWorld.addMsg
                                       (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                       (# 0) (IdealWorld.message.Content 1);
        IdealWorld.users := $0 $+ (0,
                            {|
                            IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                            IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                            {|
                            IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                            IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                            {|
                            IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                    IdealWorld.Return
                                                      (if
                                                        match
                                                          IdealWorld.message.extractContent m2 as n
                                                          return ({1 = n} + {1 = n -> False})
                                                        with
                                                        | 0 =>
                                                            right
                                                              (fun H : 1 = 0 =>
                                                               match H in (_ = y1) return (y1 = 0 -> False) with
                                                               | eq_refl =>
                                                                   fun H0 : 1 = 0 =>
                                                                   False_ind False
                                                                     (eq_ind 1
                                                                        (fun e : nat =>
                                                                         match e with
                                                                         | 0 => False
                                                                         | S _ => True
                                                                         end) I 0 H0)
                                                               end eq_refl)
                                                        | S m =>
                                                            match
                                                              match m as n return ({0 = n} + {0 = n -> False}) with
                                                              | 0 => left eq_refl
                                                              | S m0 => right (O_S m0)
                                                              end
                                                            with
                                                            | left e => left (f_equal_nat nat S 0 m e)
                                                            | right n0 => right (not_eq_S 0 m n0)
                                                            end
                                                        end
                                                       then 1
                                                       else 100))%idealworld;
                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5736398) is:
 False
subgoal 3 (ID 5736794) is:
 False
subgoal 4 (ID 5736830) is:
 False
subgoal 5 (ID 5736866) is:
 False
subgoal 6 (ID 5737046) is:
 False
subgoal 7 (ID 5737082) is:
 False
subgoal 8 (ID 5737334) is:
 False
subgoal 9 (ID 5737370) is:
 False
subgoal 10 (ID 5737478) is:
 False
subgoal 11 (ID 5737586) is:
 False








                 
                 12 focused subgoals
(shelved: 13) (ID 5736326)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H1 : exists y y0 : Map.key,
         ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                      RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                        (fun vote2 : RealWorld.message.message Nat =>
                                                         RealWorld.Return
                                                           (if
                                                             RealWorld.message.extractContent vote1 ==n
                                                             RealWorld.message.extractContent vote2
                                                            then RealWorld.message.extractContent vote1
                                                            else 100)));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y; y0];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H : exists y y0 : Map.key,
        ((y = y0 -> False) /\ incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (# 1 = # 0 -> False) /\ True) /\
        (a0, b1, b0) =
        ({|
         RealWorld.users := $0 $+ (0,
                            {|
                            RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y];
                            RealWorld.from_nons := [];
                            RealWorld.sent_nons := [(Some 0, 0)];
                            RealWorld.cur_nonce := 1 |}) $+ (1,
                            {|
                            RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y0];
                            RealWorld.from_nons := [];
                            RealWorld.sent_nons := [(Some 1, 0)];
                            RealWorld.cur_nonce := 1 |}) $+ (2,
                            {|
                            RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                    (fun vote2 : RealWorld.message.message Nat =>
                                                     RealWorld.Return
                                                       (if
                                                         match
                                                           RealWorld.message.extractContent vote2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100));
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y0; y];
                            RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                            RealWorld.sent_nons := [];
                            RealWorld.cur_nonce := 0 |});
         RealWorld.adversary := {|
                                RealWorld.key_heap := $0;
                                RealWorld.protocol := RealWorld.Return tt;
                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                      existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                RealWorld.c_heap := [];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [];
                                RealWorld.cur_nonce := 0 |};
         RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                  RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
        {|
        IdealWorld.channel_vector := IdealWorld.addMsg
                                       (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                       (# 0) (IdealWorld.message.Content 1);
        IdealWorld.users := $0 $+ (0,
                            {|
                            IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                            IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                            {|
                            IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                            IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                            {|
                            IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                    IdealWorld.Return
                                                      (if
                                                        match
                                                          IdealWorld.message.extractContent m2 as n
                                                          return ({1 = n} + {1 = n -> False})
                                                        with
                                                        | 0 =>
                                                            right
                                                              (fun H : 1 = 0 =>
                                                               match H in (_ = y1) return (y1 = 0 -> False) with
                                                               | eq_refl =>
                                                                   fun H0 : 1 = 0 =>
                                                                   False_ind False
                                                                     (eq_ind 1
                                                                        (fun e : nat =>
                                                                         match e with
                                                                         | 0 => False
                                                                         | S _ => True
                                                                         end) I 0 H0)
                                                               end eq_refl)
                                                        | S m =>
                                                            match
                                                              match m as n return ({0 = n} + {0 = n -> False}) with
                                                              | 0 => left eq_refl
                                                              | S m0 => right (O_S m0)
                                                              end
                                                            with
                                                            | left e => left (f_equal_nat nat S 0 m e)
                                                            | right n0 => right (not_eq_S 0 m n0)
                                                            end
                                                        end
                                                       then 1
                                                       else 100))%idealworld;
                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5736362) is:
 False
subgoal 3 (ID 5736398) is:
 False
subgoal 4 (ID 5736794) is:
 False
subgoal 5 (ID 5736830) is:
 False
subgoal 6 (ID 5736866) is:
 False
subgoal 7 (ID 5737046) is:
 False
subgoal 8 (ID 5737082) is:
 False
subgoal 9 (ID 5737334) is:
 False
subgoal 10 (ID 5737370) is:
 False
subgoal 11 (ID 5737478) is:
 False
subgoal 12 (ID 5737586) is:
 False


13 focused subgoals
(shelved: 13) (ID 5736074)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H1 : exists y y0 : Map.key,
         ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                      RealWorld.Return
                                                        (if
                                                          match
                                                            RealWorld.message.extractContent vote2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e : nat =>
                                                                           match e with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e => left (f_equal_nat nat S 0 m e)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0; y];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H : exists y y0 : Map.key,
        (incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
        (a0, b1, b0) =
        ({|
         RealWorld.users := $0 $+ (0,
                            {|
                            RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y0];
                            RealWorld.from_nons := [];
                            RealWorld.sent_nons := [(Some 0, 0)];
                            RealWorld.cur_nonce := 1 |}) $+ (1,
                            {|
                            RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y];
                            RealWorld.from_nons := [];
                            RealWorld.sent_nons := [(Some 1, 0)];
                            RealWorld.cur_nonce := 1 |}) $+ (2,
                            {|
                            RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                            RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                    (fun vote1 : RealWorld.message.message Nat =>
                                                     RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                       (fun vote2 : RealWorld.message.message Nat =>
                                                        RealWorld.Return
                                                          (if
                                                            RealWorld.message.extractContent vote1 ==n
                                                            RealWorld.message.extractContent vote2
                                                           then RealWorld.message.extractContent vote1
                                                           else 100)));
                            RealWorld.msg_heap := [];
                            RealWorld.c_heap := [y; y0];
                            RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                            RealWorld.sent_nons := [];
                            RealWorld.cur_nonce := 0 |});
         RealWorld.adversary := {|
                                RealWorld.key_heap := $0;
                                RealWorld.protocol := RealWorld.Return tt;
                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                      existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                RealWorld.c_heap := [];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [];
                                RealWorld.cur_nonce := 0 |};
         RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                  RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
        {|
        IdealWorld.channel_vector := IdealWorld.addMsg
                                       (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                       (# 1) (IdealWorld.message.Content 1);
        IdealWorld.users := $0 $+ (0,
                            {|
                            IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                            IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                            {|
                            IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                            IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                            {|
                            IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                    IdealWorld.Return
                                                      (if
                                                        match
                                                          IdealWorld.message.extractContent m2 as n
                                                          return ({1 = n} + {1 = n -> False})
                                                        with
                                                        | 0 =>
                                                            right
                                                              (fun H : 1 = 0 =>
                                                               match H in (_ = y1) return (y1 = 0 -> False) with
                                                               | eq_refl =>
                                                                   fun H0 : 1 = 0 =>
                                                                   False_ind False
                                                                     (eq_ind 1
                                                                        (fun e : nat =>
                                                                         match e with
                                                                         | 0 => False
                                                                         | S _ => True
                                                                         end) I 0 H0)
                                                               end eq_refl)
                                                        | S m =>
                                                            match
                                                              match m as n return ({0 = n} + {0 = n -> False}) with
                                                              | 0 => left eq_refl
                                                              | S m0 => right (O_S m0)
                                                              end
                                                            with
                                                            | left e => left (f_equal_nat nat S 0 m e)
                                                            | right n0 => right (not_eq_S 0 m n0)
                                                            end
                                                        end
                                                       then 1
                                                       else 100))%idealworld;
                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5736326) is:
 False
subgoal 3 (ID 5736362) is:
 False
subgoal 4 (ID 5736398) is:
 False
subgoal 5 (ID 5736794) is:
 False
subgoal 6 (ID 5736830) is:
 False
subgoal 7 (ID 5736866) is:
 False
subgoal 8 (ID 5737046) is:
 False
subgoal 9 (ID 5737082) is:
 False
subgoal 10 (ID 5737334) is:
 False
subgoal 11 (ID 5737370) is:
 False
subgoal 12 (ID 5737478) is:
 False
subgoal 13 (ID 5737586) is:
 False


                 
14 focused subgoals
(shelved: 13) (ID 5736038)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H1 : exists y y0 : Map.key,
         ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                      RealWorld.Return
                                                        (if
                                                          match
                                                            RealWorld.message.extractContent vote2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e : nat =>
                                                                           match e with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e => left (f_equal_nat nat S 0 m e)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0; y];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H0 : exists y y0 : Map.key,
         ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                      RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                        (fun vote2 : RealWorld.message.message Nat =>
                                                         RealWorld.Return
                                                           (if
                                                             RealWorld.message.extractContent vote1 ==n
                                                             RealWorld.message.extractContent vote2
                                                            then RealWorld.message.extractContent vote1
                                                            else 100)));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y; y0];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                   RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                        (# 0) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5736074) is:
 False
subgoal 3 (ID 5736326) is:
 False
subgoal 4 (ID 5736362) is:
 False
subgoal 5 (ID 5736398) is:
 False
subgoal 6 (ID 5736794) is:
 False
subgoal 7 (ID 5736830) is:
 False
subgoal 8 (ID 5736866) is:
 False
subgoal 9 (ID 5737046) is:
 False
subgoal 10 (ID 5737082) is:
 False
subgoal 11 (ID 5737334) is:
 False
subgoal 12 (ID 5737370) is:
 False
subgoal 13 (ID 5737478) is:
 False
subgoal 14 (ID 5737586) is:
 False


15 focused subgoals
(shelved: 13) (ID 5736002)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H1 : exists y y0 : Map.key,
         ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                      RealWorld.Return
                                                        (if
                                                          match
                                                            RealWorld.message.extractContent vote2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e : nat =>
                                                                           match e with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e => left (f_equal_nat nat S 0 m e)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0; y];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H0 : exists y y0 : Map.key,
         ((y0 = y -> False) /\ incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                      RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                        (fun vote2 : RealWorld.message.message Nat =>
                                                         RealWorld.Return
                                                           (if
                                                             RealWorld.message.extractContent vote1 ==n
                                                             RealWorld.message.extractContent vote2
                                                            then RealWorld.message.extractContent vote1
                                                            else 100)));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y; y0];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1) (IdealWorld.message.Content 1))
                                        (# 0) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5736038) is:
 False
subgoal 3 (ID 5736074) is:
 False
subgoal 4 (ID 5736326) is:
 False
subgoal 5 (ID 5736362) is:
 False
subgoal 6 (ID 5736398) is:
 False
subgoal 7 (ID 5736794) is:
 False
subgoal 8 (ID 5736830) is:
 False
subgoal 9 (ID 5736866) is:
 False
subgoal 10 (ID 5737046) is:
 False
subgoal 11 (ID 5737082) is:
 False
subgoal 12 (ID 5737334) is:
 False
subgoal 13 (ID 5737370) is:
 False
subgoal 14 (ID 5737478) is:
 False
subgoal 15 (ID 5737586) is:
 False



16 focused subgoals
(shelved: 13) (ID 5735966)
  
  b0 : bool
  a0 : RealWorld.universe Nat Unit
  b1 : IdealWorld.universe Nat
  H1 : exists y y0 : Map.key,
         ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                      RealWorld.Return
                                                        (if
                                                          match
                                                            RealWorld.message.extractContent vote2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e : nat =>
                                                                           match e with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e => left (f_equal_nat nat S 0 m e)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0; y];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  H0 : exists y y0 : Map.key,
         ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
         (a0, b1, b0) =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                      RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                        (fun vote2 : RealWorld.message.message Nat =>
                                                         RealWorld.Return
                                                           (if
                                                             RealWorld.message.extractContent vote1 ==n
                                                             RealWorld.message.extractContent vote2
                                                            then RealWorld.message.extractContent vote1
                                                            else 100)));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y; y0];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e : nat =>
                                                                          match e with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e => left (f_equal_nat nat S 0 m e)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)
  ============================
  False

subgoal 2 (ID 5736002) is:
 False
subgoal 3 (ID 5736038) is:
 False
subgoal 4 (ID 5736074) is:
 False
subgoal 5 (ID 5736326) is:
 False
subgoal 6 (ID 5736362) is:
 False
subgoal 7 (ID 5736398) is:
 False
subgoal 8 (ID 5736794) is:
 False
subgoal 9 (ID 5736830) is:
 False
subgoal 10 (ID 5736866) is:
 False
subgoal 11 (ID 5737046) is:
 False
subgoal 12 (ID 5737082) is:
 False
subgoal 13 (ID 5737334) is:
 False
subgoal 14 (ID 5737370) is:
 False
subgoal 15 (ID 5737478) is:
 False
subgoal 16 (ID 5737586) is:
 False






                          
      

      simpl.

      Unshelve.


      Ltac normalize_set_arg s :=
        match s with
        | context[@union ?A ?X ?Y] =>
          quote (@union A X Y) (@nil A)
                ltac:(fun e env =>
                        change (@union A X Y) with (interp_setexpr env e));
          rewrite <- normalize_setexpr_ok; sets_cbv
        end.

      match goal with
      | [|- multiStepClosure _ (?pr \cup ?wl) ?wl _] =>
        progress (normalize_set_arg pr; normalize_set_arg wl)
        (* 171 progress ( normalize_set_arg pr ; normalize_set_arg wl ) *)
      end.

      simpl.


        

      gen1.
      gen1.
      gen1.
      gen1.
      
      gen1.
      gen1.
      gen1.
      gen1.
      gen1.
      gen1.

      eapply msc_step_alt.
      + unfold oneStepClosure_new.

        simplify
        ; tidy
        ; idtac "rstep start"
        ; rstep
        ; idtac "istep start"
        ; istep
        ; idtac "istep done"
        ; subst
        ; canonicalize users
        ; idtac "close start".

        close.
        close.
        close.
        close.
        close.
        close.
        close.
        close.

      + 


      
      gen1. 
      gen1. 


      eapply msc_step_alt.
      + unfold oneStepClosure_new.

        simplify
        ; tidy
        ; idtac "rstep start"
        ; rstep
        ; idtac "istep start"
        ; istep
        ; idtac "istep done"
        ; subst
        ; canonicalize users
        ; idtac "close start".

        Ltac close :=
          match goal with
          | [|- [_ | _] (?ru, ?iu, _)] =>
            concrete ru
            ; concrete iuniv iu
            ; idtac "one"
            ; tidy
            ; repeat( progress (subst; cleanup) )
            ; repeat eexists
            ; propositional
            (* ; match goal with *)
            (*   | [ H : context [ _ $? _ ] |- _ ] => idtac H; fail 4 *)
            (*   | _ => idtac *)
            (*   end *)
            ; solve[ eauto
                   | canonicalize users
                     ; equality ]
          | [|- (?inv1 \cup ?inv2) (?ru, ?iu, _)] =>
            concrete inv1
            ; concrete ru
            ; concrete iuniv iu
            ; idtac "two"
            ; solve[ idtac "trying left"; left; close
                   | idtac "left fails; trying right"; right; close
                   | idtac "something is horribly wrong" (* prevent an infinite loop *)
                   ]
          | [|- ?inv (?ru, ?iu, _)] =>
            is_evar inv
            ; idtac "three"
            ; concrete ru
            ; concrete iuniv iu
            ; repeat equality1
            (* ; solve_concrete_maps *)
            ; canonicalize users
            ; clean_context
            ; repeat( progress (subst; cleanup) )
            ; NatMap.clean_map_lookups
            ; ChMaps.ChMap.clean_map_lookups
            (* ; match goal with *)
            (*   | [ H : context [ _ $? _ ] |- _ ] => idtac H; fail 4 *)
            (*   | _ => idtac *)
            (*   end *)
            ; incorp
            ; solve[ close ]
          end.

        close.
        close.
        close.
        close.
        close.
        close.
        close.
        cleanup.
        solve [ close ].

        cleanup.

        admit
        admit
        close.

        all: try solve [ close ].




      gen1.
      gen1. 
      gen1.


      + 




        ; repeat close
        ; idtac "close done".


        
        repeat gen1'.




      
      
      gen1.
      gen1.
      gen1.
      gen1.
      gen1.
      gen1.



      eapply msc_step_alt.
      + unfold oneStepClosure_new. gen1'.
      + simplify
        ; sets
        ; split_ex.
        ; propositional.
        ; repeat match goal with
                 | [H : (?x1, ?y1) = ?p |- _] =>
                   match p with
                   | (?x2, ?y2) =>
                     tryif (concrete x2; concrete y2)
                     then let H' := fresh H
                          in assert (H' : (x1, y1) = (x2, y2) -> x1 = x2 /\ y1 = y2)
                            by equality
                             ; propositional
                             ; discriminate
                     else invert H
                   | _ => invert H
                   end
                 end


        match goal with
        | [ S : step ?st _ |- _ ] =>
          concrete st;
            match goal with
            | [ LA : labels_align ?st |- _ ] =>
              eapply label_align_step_split in S; (reflexivity || eauto 2)
            | _ =>
              idtac "proving alignment 1"; assert (labels_align st)
            end
        end.

        repeat prove_alignment1.
        Import RealWorld.
        Import Eqdep.
               
        Ltac pr_message cs uid froms pat msg :=
          (assert (msg_accepted_by_pattern cs uid froms pat msg)
            by (econstructor; eauto))
          || (assert (~ msg_accepted_by_pattern cs uid froms pat msg)
              by (let MA := fresh "MA" in  unfold not; intros MA; invert MA; clean_map_lookups)).

        Ltac cleanup_msg_queue :=
          repeat 
            match goal with
            | [ H : context [ [] ++ _ ] |- _ ] =>
              rewrite !app_nil_l in H
            | [ H : context [ (_ :: _) ++ _ ] |- _ ] =>
              rewrite <- app_comm_cons in H
            | [ H : _ :: _ = _ :: _ |- _ ] =>
              invert H
            | [ H : [] = _ ++ _ :: _ |- _ ] =>
              apply nil_not_app_cons in H; contradiction
            | [ H : existT _ _ _ = existT _ _ _ |- _ ] =>
              eapply inj_pair2 in H; subst
            end.

        Ltac process_message_queue :=
          cleanup_msg_queue;
          match goal with
          | [ H : (existT _ _ ?m) :: ?msgs = ?msgs1 ++ (existT _ _ ?msg) :: ?msgs2,
                  M : msg_accepted_by_pattern ?cs ?suid ?froms ?pat ?msg
              |- _ ] =>

            pr_message cs suid froms pat m
            ; match goal with
              | [ MSA : msg_accepted_by_pattern cs suid froms pat m
                , HD : Forall _ msgs1
                  |- _ ] =>
                idtac "solving " H M MSA HD
                ; pose proof (message_queue_solve_head _ H M MSA HD)
                ; split_ex; subst
                ; cleanup_msg_queue; subst
              | [ MSA : ~ msg_accepted_by_pattern cs suid froms pat m
                , HD : Forall _ msgs1
                  |- _ ] =>
                idtac "splitting"
                ; pose proof (message_queue_split_head _ H M MSA HD)
                ; split_ex; subst
                ; invert HD
                ; cleanup_msg_queue; subst
                ; process_message_queue
              end
          end.

        process_message_queue.
        eauto.
        process_message_queue.
        eauto.
        process_message_queue.
        eauto.
        
        process_message_queue.
        process_message_queue.


      gen1.
      gen1.
      gen1.
      gen1.
      gen1.
      
    (* The remaining parts of the proof script shouldn't need to change. *)
    - intros.
      simpl in *.

      sets_invert; split_ex;
        simpl in *; autounfold with core;
          subst; simpl;
            unfold safety, alignment.
            ( split;
            [ solve_honest_actions_safe; clean_map_lookups; eauto 8
            | simpl; split; trivial; intros; rstep; subst; solve_labels_align
            ]).
      
      Unshelve.
      all: auto.

  Qed.






1 focused subgoal
(shelved: 13) (ID 5261829)
  
  ============================
  multiStepClosure {| Initial := {(ru0, iu0, true)}; Step := step |}
    (((((((((((({(ru0, iu0, true)} \cup
                ([e
                 | exists y : Map.key,
                     True /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                 (fun c : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Send 2 c) (... => ...));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.SignEncrypt 1 3 2 (RealWorld.message.Content 1))
                                                                 (fun c : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Send 2 c)
                                                                    (fun ... => RealWorld.Return 1));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                 (fun voteC1 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                    (fun voteC2 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 0);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                 m2 <- IdealWorld.Recv (# 1);
                                                                 IdealWorld.Return
                                                                   (if ... ==n ...
                                                                    then IdealWorld.message.extractContent m1
                                                                    else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 [e
                 | exists y : Map.key,
                     True /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.SignEncrypt 0 3 2 (RealWorld.message.Content 1))
                                                                 (fun c : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Send 2 c) (... => ...));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                 (fun c : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Send 2 c)
                                                                    (fun ... => RealWorld.Return 1));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                 (fun voteC1 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                    (fun voteC2 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 0);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                 m2 <- IdealWorld.Recv (# 1);
                                                                 IdealWorld.Return
                                                                   (if ... ==n ...
                                                                    then IdealWorld.message.extractContent m1
                                                                    else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)])) \cup
               ([e
                | exists y : Map.key,
                    True /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y))
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind
                                                                (RealWorld.SignEncrypt 1 3 2 (RealWorld.message.Content 1))
                                                                (fun c : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind (RealWorld.Send 2 c)
                                                                   (fun _ : unit => RealWorld.Return 1));
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind
                                                                (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                (fun voteC1 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                   (fun voteC2 : RealWorld.crypto Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                      (fun ... => RealWorld.Bind ... ...)));
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 0);
                                                                IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                m2 <- IdealWorld.Recv (# 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    IdealWorld.message.extractContent m1 ==n
                                                                    IdealWorld.message.extractContent m2
                                                                   then IdealWorld.message.extractContent m1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     (y <> y0 /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                 (fun c : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Send 2 c) (... => ...));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                                 (fun c : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Send 2 c)
                                                                    (fun ... => RealWorld.Return 1));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                 (fun voteC1 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                    (fun voteC2 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 0);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                 m2 <- IdealWorld.Recv (# 1);
                                                                 IdealWorld.Return
                                                                   (if ... ==n ...
                                                                    then IdealWorld.message.extractContent m1
                                                                    else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y y0 : Map.key,
                      (y <> y0 /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return (...))
                                                                  (fun ... => RealWorld.Bind ... ...);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                  (fun c : ... => RealWorld.Bind (...) (...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                  (fun voteC1 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Recv ...) (... => ...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Send (...) (# 0); IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                  IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                  m2 <- IdealWorld.Recv (# 1); IdealWorld.Return (... ... ...))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  [e
                  | exists y : Map.key,
                      True /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.SignEncrypt 0 3 2 (...))
                                                                  (fun ... => RealWorld.Bind ... ...);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y))
                                                                  (fun _ : unit => RealWorld.Return 1);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                  (fun voteC1 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Recv ...) (... => ...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Send (...) (# 0); IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                  IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                  m2 <- IdealWorld.Recv (# 1); IdealWorld.Return (... ... ...))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)])))) \cup
              ([e
               | exists y y0 : Map.key,
                   (y <> y0 /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y))
                                                               (fun _ : unit => RealWorld.Return 1);
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                               (fun c : RealWorld.crypto Nat =>
                                                                RealWorld.Bind (RealWorld.Send 2 c)
                                                                  (fun _ : unit => RealWorld.Return 1));
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind
                                                               (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                               (fun voteC1 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                  (fun voteC2 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                                      RealWorld.Bind (RealWorld.Decrypt voteC2) (... => ...))));
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 0);
                                                               IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                               IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                               m2 <- IdealWorld.Recv (# 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   IdealWorld.message.extractContent m1 ==n
                                                                   IdealWorld.message.extractContent m2
                                                                  then IdealWorld.message.extractContent m1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y : Map.key,
                    (incl [y] [y] /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind
                                                                (RealWorld.SignEncrypt 1 3 2 (RealWorld.message.Content 1))
                                                                (fun c : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind (RealWorld.Send 2 c)
                                                                   (fun _ : unit => RealWorld.Return 1));
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind
                                                                (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                (fun voteC1 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                   (fun voteC2 : RealWorld.crypto Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                      (fun ... => RealWorld.Bind ... ...)));
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                   (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                m2 <- IdealWorld.Recv (# 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    IdealWorld.message.extractContent m1 ==n
                                                                    IdealWorld.message.extractContent m2
                                                                   then IdealWorld.message.extractContent m1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     ((y = y0 -> False) /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                 (fun c : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Send 2 c) (... => ...));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y0))
                                                                 (fun _ : unit => RealWorld.Return 1);
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                 (fun voteC1 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                    (fun voteC2 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 0);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                 m2 <- IdealWorld.Recv (# 1);
                                                                 IdealWorld.Return
                                                                   (if ... ==n ...
                                                                    then IdealWorld.message.extractContent m1
                                                                    else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y y0 : Map.key,
                      ((y = y0 -> False) /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (...))
                                                                  (fun ... => RealWorld.Return 1);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                  (fun c : ... => RealWorld.Bind (...) (...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                  (fun voteC1 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Recv ...) (... => ...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Send (...) (# 0); IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                  IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                  m2 <- IdealWorld.Recv (# 1); IdealWorld.Return (... ... ...))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       ((y = y0 -> False) /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (...) (...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 ...) (... => ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Send ... ...; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                   m2 <- IdealWorld.Recv ...; IdealWorld.Return ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   ([e
                    | exists y y0 : Map.key,
                        (y <> y0 /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Bind ... ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m1 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                    [e
                    | exists y : Map.key,
                        (incl [y] [y] /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Bind ... ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [(..., 0)];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (...)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                         (RealWorld.SignedCiphertext y)];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 1) (IdealWorld.message.Content 1);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m1 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)]))))))) \cup
             ([e
              | exists y y0 : Map.key,
                  ((y = y0 -> False) /\ True) /\
                  e =
                  ({|
                   RealWorld.users := $0 $+ (0,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y))
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 1 |}) $+ (1,
                                      {|
                                      RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y0))
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 1 |}) $+ (2,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                              (fun voteC1 : RealWorld.crypto Nat =>
                                                               RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                 (fun voteC2 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                    (fun vote1 : RealWorld.message.message Nat =>
                                                                     RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                       (fun vote2 : ... => RealWorld.Return (...)))));
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |});
                   RealWorld.adversary := {|
                                          RealWorld.key_heap := $0;
                                          RealWorld.protocol := RealWorld.Return tt;
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |};
                   RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                            (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                   RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                  {|
                  IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                  IdealWorld.users := $0 $+ (0,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 0);
                                                              IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                              IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                      {|
                                      IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                              m2 <- IdealWorld.Recv (# 1);
                                                              IdealWorld.Return
                                                                (if
                                                                  IdealWorld.message.extractContent m1 ==n
                                                                  IdealWorld.message.extractContent m2
                                                                 then IdealWorld.message.extractContent m1
                                                                 else 100))%idealworld;
                                      IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
              ([e
               | exists y y0 : Map.key,
                   ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                               (fun _ : unit => RealWorld.Return 1);
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 0, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                               (fun c : RealWorld.crypto Nat =>
                                                                RealWorld.Bind (RealWorld.Send 2 c)
                                                                  (fun _ : unit => RealWorld.Return 1));
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind
                                                               (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                               (fun voteC1 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                  (fun voteC2 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                                      RealWorld.Bind (RealWorld.Decrypt voteC2) (... => ...))));
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                  (IdealWorld.message.Content 1);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                               IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                               m2 <- IdealWorld.Recv (# 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   IdealWorld.message.extractContent m1 ==n
                                                                   IdealWorld.message.extractContent m2
                                                                  then IdealWorld.message.extractContent m1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y : Map.key,
                    (incl [y] [y] /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Return 1;
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind
                                                                (RealWorld.SignEncrypt 1 3 2 (RealWorld.message.Content 1))
                                                                (fun c : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind (RealWorld.Send 2 c)
                                                                   (fun _ : unit => RealWorld.Return 1));
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind
                                                                (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                (fun voteC1 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                   (fun voteC2 : RealWorld.crypto Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                      (fun ... => RealWorld.Bind ... ...)));
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                   (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                m2 <- IdealWorld.Recv (# 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    IdealWorld.message.extractContent m1 ==n
                                                                    IdealWorld.message.extractContent m2
                                                                   then IdealWorld.message.extractContent m1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     (incl [y] [y] /\ y <> y0 /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                 (fun _ : unit => RealWorld.Return 1);
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 0, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                                 (fun c : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Send 2 c)
                                                                    (fun ... => RealWorld.Return 1));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                 (fun voteC1 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                    (fun voteC2 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                    (IdealWorld.message.Content 1);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                 m2 <- IdealWorld.Recv (# 1);
                                                                 IdealWorld.Return
                                                                   (if ... ==n ...
                                                                    then IdealWorld.message.extractContent m1
                                                                    else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y : Map.key,
                      (incl [y] [y] /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                  (fun ... => RealWorld.Return 1);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 0, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind
                                                                  (RealWorld.SignEncrypt 1 3 2 (RealWorld.message.Content 1))
                                                                  (fun c : ... => RealWorld.Bind (...) (...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                  (fun voteC1 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Recv ...) (... => ...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [(Some 0, 0)];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                     (# 0) (IdealWorld.message.Content 1);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                  IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                  m2 <- IdealWorld.Recv (# 1); IdealWorld.Return (... ... ...))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       ((y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (...) (...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (... => ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 1, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                        (RealWorld.SignedCiphertext y0)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 1) (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                   m2 <- IdealWorld.Recv ...; IdealWorld.Return ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   ([e
                    | exists y y0 : Map.key,
                        ((y = y0 -> False) /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Bind ... ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := #0 #+ (# 0, []) #+ (# 1, []);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m1 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                    ([e
                     | exists y y0 : Map.key,
                         ((y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
                         e =
                         ({|
                          RealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ...; ...; ...; ...; ...; ... |}) $+ (2,
                                             {|
                                             RealWorld.key_heap := ...;
                                             RealWorld.protocol := ...;
                                             RealWorld.msg_heap := [...];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |});
                          RealWorld.adversary := {|
                                                 RealWorld.key_heap := $0;
                                                 RealWorld.protocol := RealWorld.Return tt;
                                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat ...];
                                                 RealWorld.c_heap := [];
                                                 RealWorld.from_nons := [];
                                                 RealWorld.sent_nons := [];
                                                 RealWorld.cur_nonce := 0 |};
                          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 ... ...) $+ (y0,
                                                   RealWorld.SigEncCipher 0 3 2 (..., 0) (...));
                          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                         {|
                         IdealWorld.channel_vector := IdealWorld.addMsg (... #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1);
                         IdealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ... |}) $+ (2,
                                             {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) |}, true)] \cup
                     ([e
                      | exists y y0 : Map.key,
                          ((y = y0 -> False) /\ (... -> False) /\ incl [y] [y] /\ True) /\
                          e =
                          ({|
                           RealWorld.users := ... $+ (2, ...);
                           RealWorld.adversary := {| ...; ...; ...; ...; ...; ...; ... |};
                           RealWorld.all_ciphers := ... $+ (y0, ...);
                           RealWorld.all_keys := ... $+ (3, ekey 3) |},
                          {| IdealWorld.channel_vector := IdealWorld.addMsg ... ... ...; IdealWorld.users := ... $+ (2, ...) |},
                          true)] \cup
                      ([e
                       | exists y y0 : Map.key,
                           (incl [y] [y] /\ ... /\ True) /\ e = ({| ...; ...; ...; ... |}, {| ...; ... |}, true)] \cup
                       [e | exists y : Map.key, (incl [y] [y] /\ True) /\ e = ({| ...; ...; ...; ... |}, {| ...; ... |}, true)]))))))))))) \cup
            ([e
             | exists y y0 : Map.key,
                 ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ True) /\
                 e =
                 ({|
                  RealWorld.users := $0 $+ (0,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 0, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (1,
                                     {|
                                     RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y0))
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 1 |}) $+ (2,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                             (fun voteC1 : RealWorld.crypto Nat =>
                                                              RealWorld.Bind
                                                                (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                (fun voteC2 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                   (fun vote1 : RealWorld.message.message Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                      (fun vote2 : RealWorld.message.message Nat =>
                                                                       RealWorld.Return (if ... then ... else 100)))));
                                     RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                     RealWorld.c_heap := [];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |});
                  RealWorld.adversary := {|
                                         RealWorld.key_heap := $0;
                                         RealWorld.protocol := RealWorld.Return tt;
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |};
                  RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                           (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                  RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                 {|
                 IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                (IdealWorld.message.Content 1);
                 IdealWorld.users := $0 $+ (0,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                             IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                     {|
                                     IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                             m2 <- IdealWorld.Recv (# 1);
                                                             IdealWorld.Return
                                                               (if
                                                                 IdealWorld.message.extractContent m1 ==n
                                                                 IdealWorld.message.extractContent m2
                                                                then IdealWorld.message.extractContent m1
                                                                else 100))%idealworld;
                                     IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
             ([e
              | exists y y0 : Map.key,
                  ((y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
                  e =
                  ({|
                   RealWorld.users := $0 $+ (0,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y))
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 1 |}) $+ (1,
                                      {|
                                      RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 1, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (2,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                              (fun voteC1 : RealWorld.crypto Nat =>
                                                               RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                 (fun voteC2 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                    (fun vote1 : RealWorld.message.message Nat =>
                                                                     RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                       (fun vote2 : ... => RealWorld.Return (...)))));
                                      RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                      RealWorld.c_heap := [];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |});
                   RealWorld.adversary := {|
                                          RealWorld.key_heap := $0;
                                          RealWorld.protocol := RealWorld.Return tt;
                                          RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |};
                   RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                            (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                   RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                  {|
                  IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                 (IdealWorld.message.Content 1);
                  IdealWorld.users := $0 $+ (0,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 0);
                                                              IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                      {|
                                      IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                              m2 <- IdealWorld.Recv (# 1);
                                                              IdealWorld.Return
                                                                (if
                                                                  IdealWorld.message.extractContent m1 ==n
                                                                  IdealWorld.message.extractContent m2
                                                                 then IdealWorld.message.extractContent m1
                                                                 else 100))%idealworld;
                                      IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
              ([e
               | exists y y0 : Map.key,
                   ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Return 1;
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 0, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                               (fun c : RealWorld.crypto Nat =>
                                                                RealWorld.Bind (RealWorld.Send 2 c)
                                                                  (fun _ : unit => RealWorld.Return 1));
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind
                                                               (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                               (fun voteC1 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                  (fun voteC2 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                                      RealWorld.Bind (RealWorld.Decrypt voteC2) (... => ...))));
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                  (IdealWorld.message.Content 1);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                               IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                               m2 <- IdealWorld.Recv (# 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   IdealWorld.message.extractContent m1 ==n
                                                                   IdealWorld.message.extractContent m2
                                                                  then IdealWorld.message.extractContent m1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y y0 : Map.key,
                    ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                                (fun c : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind (RealWorld.Send 2 c)
                                                                   (fun _ : unit => RealWorld.Return 1));
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y0];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 1 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                (fun voteC1 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                   (fun voteC2 : RealWorld.crypto Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                      (fun ... => RealWorld.Bind ... ...)));
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [(Some 0, 0)];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                              (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                   (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                m2 <- IdealWorld.Recv (# 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    IdealWorld.message.extractContent m1 ==n
                                                                    IdealWorld.message.extractContent m2
                                                                   then IdealWorld.message.extractContent m1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     (incl [y] [y] /\ y <> y0 /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Return 1;
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 0, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                                 (fun c : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Send 2 c)
                                                                    (fun ... => RealWorld.Return 1));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                 (fun voteC1 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                    (fun voteC2 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                    (IdealWorld.message.Content 1);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                 m2 <- IdealWorld.Recv (# 1);
                                                                 IdealWorld.Return
                                                                   (if ... ==n ...
                                                                    then IdealWorld.message.extractContent m1
                                                                    else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y : Map.key,
                      (incl [y] [y] /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Return 1;
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 0, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind
                                                                  (RealWorld.SignEncrypt 1 3 2 (RealWorld.message.Content 1))
                                                                  (fun c : ... => RealWorld.Bind (...) (...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                  (fun voteC1 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Recv ...) (... => ...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [(Some 0, 0)];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                     (# 0) (IdealWorld.message.Content 1);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                  IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                  m2 <- IdealWorld.Recv (# 1); IdealWorld.Return (... ... ...))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       (incl [y] [y] /\ (y = y0 -> False) /\ (y = y0 -> False) /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (...) (...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 0, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return ...) (... => ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [(Some 0, 0)];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 0) (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Send ... ...; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m1 <- IdealWorld.Return (...);
                                                                   m2 <- IdealWorld.Recv ...; IdealWorld.Return ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   ([e
                    | exists y y0 : Map.key,
                        (incl [y] [y] /\ y <> y0 /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [...];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Bind ... ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [(Some 0, 0)];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                         (RealWorld.SignedCiphertext y)];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 0) (IdealWorld.message.Content 1);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m1 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                    ([e
                     | exists y : Map.key,
                         (incl [y] [y] /\ True) /\
                         e =
                         ({|
                          RealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ...; ...; ...; ...; ...; ... |}) $+ (2,
                                             {|
                                             RealWorld.key_heap := ...;
                                             RealWorld.protocol := ...;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := [y];
                                             RealWorld.from_nons := [...];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |});
                          RealWorld.adversary := {|
                                                 RealWorld.key_heap := $0;
                                                 RealWorld.protocol := RealWorld.Return tt;
                                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat ...];
                                                 RealWorld.c_heap := [];
                                                 RealWorld.from_nons := [];
                                                 RealWorld.sent_nons := [];
                                                 RealWorld.cur_nonce := 0 |};
                          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (..., 0) (...));
                          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                         {|
                         IdealWorld.channel_vector := IdealWorld.addMsg (... #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1);
                         IdealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ... |}) $+ (2,
                                             {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) |}, true)] \cup
                     ([e
                      | exists y y0 : Map.key,
                          ((y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
                          e =
                          ({|
                           RealWorld.users := ... $+ (2, ...);
                           RealWorld.adversary := {| ...; ...; ...; ...; ...; ...; ... |};
                           RealWorld.all_ciphers := ... $+ (y0, ...);
                           RealWorld.all_keys := ... $+ (3, ekey 3) |},
                          {| IdealWorld.channel_vector := IdealWorld.addMsg ... ... ...; IdealWorld.users := ... $+ (2, ...) |},
                          true)] \cup
                      ([e
                       | exists y y0 : Map.key, ((...) /\ ... /\ ...) /\ e = ({| ...; ...; ...; ... |}, {| ...; ... |}, true)] \cup
                       ([e | exists y y0 : Map.key, (...) /\ e = ...] \cup ([e | exists ..., ...] \cup (... \cup ...))))))))))))))) \cup
           ([e
            | exists y y0 : Map.key,
                ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ True) /\
                e =
                ({|
                 RealWorld.users := $0 $+ (0,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Return 1;
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 0, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (1,
                                    {|
                                    RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y0))
                                                            (fun _ : unit => RealWorld.Return 1);
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y0];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 1 |}) $+ (2,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                            (fun voteC1 : RealWorld.crypto Nat =>
                                                             RealWorld.Bind
                                                               (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                               (fun voteC2 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                  (fun vote1 : RealWorld.message.message Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                                      RealWorld.Return
                                                                        (if
                                                                          RealWorld.message.extractContent vote1 ==n
                                                                          RealWorld.message.extractContent vote2
                                                                         then RealWorld.message.extractContent vote1
                                                                         else 100)))));
                                    RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                    RealWorld.c_heap := [];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |});
                 RealWorld.adversary := {|
                                        RealWorld.key_heap := $0;
                                        RealWorld.protocol := RealWorld.Return tt;
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |};
                 RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                          (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                 RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                {|
                IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                               (IdealWorld.message.Content 1);
                IdealWorld.users := $0 $+ (0,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                            IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                    {|
                                    IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                            m2 <- IdealWorld.Recv (# 1);
                                                            IdealWorld.Return
                                                              (if
                                                                IdealWorld.message.extractContent m1 ==n
                                                                IdealWorld.message.extractContent m2
                                                               then IdealWorld.message.extractContent m1
                                                               else 100))%idealworld;
                                    IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
            ([e
             | exists y y0 : Map.key,
                 ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                 e =
                 ({|
                  RealWorld.users := $0 $+ (0,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 0, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (1,
                                     {|
                                     RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y0))
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 1 |}) $+ (2,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                             (fun voteC1 : RealWorld.crypto Nat =>
                                                              RealWorld.Bind
                                                                (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                (fun voteC2 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                   (fun vote1 : RealWorld.message.message Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                      (fun vote2 : RealWorld.message.message Nat =>
                                                                       RealWorld.Return (if ... then ... else 100)))));
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [(Some 0, 0)];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |});
                  RealWorld.adversary := {|
                                         RealWorld.key_heap := $0;
                                         RealWorld.protocol := RealWorld.Return tt;
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |};
                  RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                           (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                  RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                 {|
                 IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                (IdealWorld.message.Content 1);
                 IdealWorld.users := $0 $+ (0,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                             IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                     {|
                                     IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                             m2 <- IdealWorld.Recv (# 1);
                                                             IdealWorld.Return
                                                               (if
                                                                 IdealWorld.message.extractContent m1 ==n
                                                                 IdealWorld.message.extractContent m2
                                                                then IdealWorld.message.extractContent m1
                                                                else 100))%idealworld;
                                     IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
             ([e
              | exists y y0 : Map.key,
                  ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ True) /\
                  e =
                  ({|
                   RealWorld.users := $0 $+ (0,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 0, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (1,
                                      {|
                                      RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 1, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (2,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                              (fun voteC1 : RealWorld.crypto Nat =>
                                                               RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                 (fun voteC2 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                    (fun vote1 : RealWorld.message.message Nat =>
                                                                     RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                       (fun vote2 : ... => RealWorld.Return (...)))));
                                      RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                            existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                      RealWorld.c_heap := [];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |});
                   RealWorld.adversary := {|
                                          RealWorld.key_heap := $0;
                                          RealWorld.protocol := RealWorld.Return tt;
                                          RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |};
                   RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                            (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                   RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                  {|
                  IdealWorld.channel_vector := IdealWorld.addMsg
                                                 (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                    (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                  IdealWorld.users := $0 $+ (0,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                      {|
                                      IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                              m2 <- IdealWorld.Recv (# 1);
                                                              IdealWorld.Return
                                                                (if
                                                                  IdealWorld.message.extractContent m1 ==n
                                                                  IdealWorld.message.extractContent m2
                                                                 then IdealWorld.message.extractContent m1
                                                                 else 100))%idealworld;
                                      IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
              ([e
               | exists y y0 : Map.key,
                   ((y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y))
                                                               (fun _ : unit => RealWorld.Return 1);
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Return 1;
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 1, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind
                                                               (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                               (fun voteC1 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                  (fun voteC2 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                                      RealWorld.Bind (RealWorld.Decrypt voteC2) (... => ...))));
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                  (IdealWorld.message.Content 1);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 0);
                                                               IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                               m2 <- IdealWorld.Recv (# 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   IdealWorld.message.extractContent m1 ==n
                                                                   IdealWorld.message.extractContent m2
                                                                  then IdealWorld.message.extractContent m1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y y0 : Map.key,
                    ((y = y0 -> False) /\ incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y0];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 1, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind
                                                                (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                (fun voteC1 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                   (fun voteC2 : RealWorld.crypto Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                      (fun ... => RealWorld.Bind ... ...)));
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                              existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                  existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                              (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg
                                                   (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                m2 <- IdealWorld.Recv (# 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    IdealWorld.message.extractContent m1 ==n
                                                                    IdealWorld.message.extractContent m2
                                                                   then IdealWorld.message.extractContent m1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Return 1;
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 0, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                                 (fun c : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Send 2 c)
                                                                    (fun ... => RealWorld.Return 1));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                 (fun voteC1 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                    (fun voteC2 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [(Some 0, 0)];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                    (IdealWorld.message.Content 1);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                 IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                 m2 <- IdealWorld.Recv (# 1);
                                                                 IdealWorld.Return
                                                                   (if ... ==n ...
                                                                    then IdealWorld.message.extractContent m1
                                                                    else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y y0 : Map.key,
                      ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                  (fun ... => RealWorld.Return 1);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 0, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind
                                                                  (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                                  (fun c : ... => RealWorld.Bind (...) (...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                  (fun voteC2 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt ...) (... => ...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [(Some 0, 0)];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                     (# 0) (IdealWorld.message.Content 1);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                                  IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                  m2 <- IdealWorld.Recv (# 1); IdealWorld.Return (... ... ...))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       (incl [y] [y] /\ (y = y0 -> False) /\ (y = y0 -> False) /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Return 1;
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 0, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return ...) (... => ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [(Some 0, 0)];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 0) (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Send ... ...; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m1 <- IdealWorld.Return (...);
                                                                   m2 <- IdealWorld.Recv ...; IdealWorld.Return ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   ([e
                    | exists y y0 : Map.key,
                        (incl [y] [y] /\ y <> y0 /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [...];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Bind ... ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [(Some 0, 0)];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                         (RealWorld.SignedCiphertext y)];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 0) (IdealWorld.message.Content 1);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m1 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                    ([e
                     | exists y : Map.key,
                         (incl [y] [y] /\ True) /\
                         e =
                         ({|
                          RealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ...; ...; ...; ...; ...; ... |}) $+ (2,
                                             {|
                                             RealWorld.key_heap := ...;
                                             RealWorld.protocol := ...;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := [y];
                                             RealWorld.from_nons := [...];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |});
                          RealWorld.adversary := {|
                                                 RealWorld.key_heap := $0;
                                                 RealWorld.protocol := RealWorld.Return tt;
                                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat ...];
                                                 RealWorld.c_heap := [];
                                                 RealWorld.from_nons := [];
                                                 RealWorld.sent_nons := [];
                                                 RealWorld.cur_nonce := 0 |};
                          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (..., 0) (...));
                          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                         {|
                         IdealWorld.channel_vector := IdealWorld.addMsg (... #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1);
                         IdealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ... |}) $+ (2,
                                             {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) |}, true)] \cup
                     ([e
                      | exists y y0 : Map.key,
                          (incl [y] [y] /\ y <> y0 /\ True) /\
                          e =
                          ({|
                           RealWorld.users := ... $+ (2, ...);
                           RealWorld.adversary := {| ...; ...; ...; ...; ...; ...; ... |};
                           RealWorld.all_ciphers := ... $+ (y0, ...);
                           RealWorld.all_keys := ... $+ (3, ekey 3) |},
                          {| IdealWorld.channel_vector := IdealWorld.addMsg ... ... ...; IdealWorld.users := ... $+ (2, ...) |},
                          true)] \cup
                      ([e
                       | exists y y0 : Map.key, ((...) /\ ... /\ ...) /\ e = ({| ...; ...; ...; ... |}, {| ...; ... |}, true)] \cup
                       ([e | exists y y0 : Map.key, (...) /\ e = ...] \cup ([e | exists ..., ...] \cup (... \cup ...)))))))))))))))) \cup
          ([e
           | exists y y0 : Map.key,
               ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
               e =
               ({|
                RealWorld.users := $0 $+ (0,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Return 1;
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 0, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (1,
                                   {|
                                   RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y0))
                                                           (fun _ : unit => RealWorld.Return 1);
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y0];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 1 |}) $+ (2,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                           (fun voteC1 : RealWorld.crypto Nat =>
                                                            RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                              (fun voteC2 : RealWorld.crypto Nat =>
                                                               RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                 (fun vote1 : RealWorld.message.message Nat =>
                                                                  RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                    (fun vote2 : RealWorld.message.message Nat =>
                                                                     RealWorld.Return
                                                                       (if
                                                                         RealWorld.message.extractContent vote1 ==n
                                                                         RealWorld.message.extractContent vote2
                                                                        then RealWorld.message.extractContent vote1
                                                                        else 100)))));
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y];
                                   RealWorld.from_nons := [(Some 0, 0)];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 0 |});
                RealWorld.adversary := {|
                                       RealWorld.key_heap := $0;
                                       RealWorld.protocol := RealWorld.Return tt;
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |};
                RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                         (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
               {|
               IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                              (IdealWorld.message.Content 1);
               IdealWorld.users := $0 $+ (0,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                           IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                   {|
                                   IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                           m2 <- IdealWorld.Recv (# 1);
                                                           IdealWorld.Return
                                                             (if
                                                               IdealWorld.message.extractContent m1 ==n
                                                               IdealWorld.message.extractContent m2
                                                              then IdealWorld.message.extractContent m1
                                                              else 100))%idealworld;
                                   IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
           ([e
            | exists y y0 : Map.key,
                ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ True) /\
                e =
                ({|
                 RealWorld.users := $0 $+ (0,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Return 1;
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 0, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (1,
                                    {|
                                    RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                            (fun _ : unit => RealWorld.Return 1);
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y0];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 1, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (2,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                            (fun voteC1 : RealWorld.crypto Nat =>
                                                             RealWorld.Bind
                                                               (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                               (fun voteC2 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                  (fun vote1 : RealWorld.message.message Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                                      RealWorld.Return
                                                                        (if
                                                                          RealWorld.message.extractContent vote1 ==n
                                                                          RealWorld.message.extractContent vote2
                                                                         then RealWorld.message.extractContent vote1
                                                                         else 100)))));
                                    RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                          existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                    RealWorld.c_heap := [];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |});
                 RealWorld.adversary := {|
                                        RealWorld.key_heap := $0;
                                        RealWorld.protocol := RealWorld.Return tt;
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                              existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |};
                 RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                          (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                 RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                {|
                IdealWorld.channel_vector := IdealWorld.addMsg
                                               (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                  (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                IdealWorld.users := $0 $+ (0,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                    {|
                                    IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                            m2 <- IdealWorld.Recv (# 1);
                                                            IdealWorld.Return
                                                              (if
                                                                IdealWorld.message.extractContent m1 ==n
                                                                IdealWorld.message.extractContent m2
                                                               then IdealWorld.message.extractContent m1
                                                               else 100))%idealworld;
                                    IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
            ([e
             | exists y y0 : Map.key,
                 ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                 e =
                 ({|
                  RealWorld.users := $0 $+ (0,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 0, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (1,
                                     {|
                                     RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y0))
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 1 |}) $+ (2,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                             (fun voteC2 : RealWorld.crypto Nat =>
                                                              RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                (fun vote1 : RealWorld.message.message Nat =>
                                                                 RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                   (fun vote2 : RealWorld.message.message Nat =>
                                                                    RealWorld.Return
                                                                      (if
                                                                        RealWorld.message.extractContent vote1 ==n
                                                                        RealWorld.message.extractContent vote2
                                                                       then RealWorld.message.extractContent vote1
                                                                       else 100))));
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [(Some 0, 0)];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |});
                  RealWorld.adversary := {|
                                         RealWorld.key_heap := $0;
                                         RealWorld.protocol := RealWorld.Return tt;
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |};
                  RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                           (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                  RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                 {|
                 IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                (IdealWorld.message.Content 1);
                 IdealWorld.users := $0 $+ (0,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                             IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                     {|
                                     IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                             m2 <- IdealWorld.Recv (# 1);
                                                             IdealWorld.Return
                                                               (if
                                                                 IdealWorld.message.extractContent m1 ==n
                                                                 IdealWorld.message.extractContent m2
                                                                then IdealWorld.message.extractContent m1
                                                                else 100))%idealworld;
                                     IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
             ([e
              | exists y y0 : Map.key,
                  ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
                  e =
                  ({|
                   RealWorld.users := $0 $+ (0,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 0, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (1,
                                      {|
                                      RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 1, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (2,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                              (fun voteC1 : RealWorld.crypto Nat =>
                                                               RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                 (fun voteC2 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                    (fun vote1 : RealWorld.message.message Nat =>
                                                                     RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                       (fun vote2 : ... => RealWorld.Return (...)))));
                                      RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [(Some 0, 0)];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |});
                   RealWorld.adversary := {|
                                          RealWorld.key_heap := $0;
                                          RealWorld.protocol := RealWorld.Return tt;
                                          RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |};
                   RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                            (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                   RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                  {|
                  IdealWorld.channel_vector := IdealWorld.addMsg
                                                 (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                    (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                  IdealWorld.users := $0 $+ (0,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                      {|
                                      IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                              m2 <- IdealWorld.Recv (# 1);
                                                              IdealWorld.Return
                                                                (if
                                                                  IdealWorld.message.extractContent m1 ==n
                                                                  IdealWorld.message.extractContent m2
                                                                 then IdealWorld.message.extractContent m1
                                                                 else 100))%idealworld;
                                      IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
              ([e
               | exists y y0 : Map.key,
                   ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                               (fun _ : unit => RealWorld.Return 1);
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 0, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Return 1;
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 1, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind
                                                               (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                               (fun voteC1 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                  (fun voteC2 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                                      RealWorld.Bind (RealWorld.Decrypt voteC2) (... => ...))));
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                             existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                 existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := IdealWorld.addMsg
                                                  (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                     (# 0) (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                               m2 <- IdealWorld.Recv (# 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   IdealWorld.message.extractContent m1 ==n
                                                                   IdealWorld.message.extractContent m2
                                                                  then IdealWorld.message.extractContent m1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y y0 : Map.key,
                    ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 0 = # 1 -> False) /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y0];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 1, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                (fun voteC1 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                   (fun voteC2 : RealWorld.crypto Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                      (fun ... => RealWorld.Bind ... ...)));
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [(Some 0, 0)];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                  existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                              (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg
                                                   (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 0) (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                m2 <- IdealWorld.Recv (# 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    IdealWorld.message.extractContent m1 ==n
                                                                    IdealWorld.message.extractContent m2
                                                                   then IdealWorld.message.extractContent m1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     ((y = y0 -> False) /\ incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                 (fun _ : unit => RealWorld.Return 1);
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 0, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Return 1;
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 1, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                 (fun voteC1 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                    (fun voteC2 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                               existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                   existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := IdealWorld.addMsg
                                                    (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                    (IdealWorld.message.Content 1);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                 m2 <- IdealWorld.Recv (# 1);
                                                                 IdealWorld.Return
                                                                   (if ... ==n ...
                                                                    then IdealWorld.message.extractContent m1
                                                                    else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y y0 : Map.key,
                      ((y = y0 -> False) /\ incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Return 1;
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 0, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                  (fun _ : unit => RealWorld.Return 1);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 1, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                  (fun voteC1 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Recv ...) (... => ...));
                                          RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                    existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := IdealWorld.addMsg
                                                     (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                        (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                     (IdealWorld.message.Content 1);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                  m2 <- IdealWorld.Recv (# 1); IdealWorld.Return (... ... ...))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (...) (...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 0, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (... => ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 1, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [existT (fun ... => RealWorld.crypto H) Nat
                                                                    (RealWorld.SignedCiphertext y0)];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [(Some 0, 0)];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                        (RealWorld.SignedCiphertext y0);
                                                                     existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg
                                                      (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                         (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                      (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m1 <- IdealWorld.Return (...);
                                                                   m2 <- IdealWorld.Recv ...; IdealWorld.Return ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   ([e
                    | exists y y0 : Map.key,
                        ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [...];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Bind ... ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [(Some 0, 0)];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                         (RealWorld.SignedCiphertext y)];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 0) (IdealWorld.message.Content 1);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m1 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                    ([e
                     | exists y y0 : Map.key,
                         (incl [y] [y] /\ y <> y0 /\ True) /\
                         e =
                         ({|
                          RealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ...; ...; ...; ...; ...; ... |}) $+ (2,
                                             {|
                                             RealWorld.key_heap := ...;
                                             RealWorld.protocol := ...;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := [y];
                                             RealWorld.from_nons := [...];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |});
                          RealWorld.adversary := {|
                                                 RealWorld.key_heap := $0;
                                                 RealWorld.protocol := RealWorld.Return tt;
                                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat ...];
                                                 RealWorld.c_heap := [];
                                                 RealWorld.from_nons := [];
                                                 RealWorld.sent_nons := [];
                                                 RealWorld.cur_nonce := 0 |};
                          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 ... ...) $+ (y0,
                                                   RealWorld.SigEncCipher 1 3 2 (..., 0) (...));
                          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                         {|
                         IdealWorld.channel_vector := IdealWorld.addMsg (... #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1);
                         IdealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ... |}) $+ (2,
                                             {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) |}, true)] \cup
                     ([e
                      | exists y y0 : Map.key,
                          ((y = y0 -> False) /\ (... -> False) /\ incl [y] [y] /\ ... /\ True) /\
                          e =
                          ({|
                           RealWorld.users := ... $+ (2, ...);
                           RealWorld.adversary := {| ...; ...; ...; ...; ...; ...; ... |};
                           RealWorld.all_ciphers := ... $+ (y0, ...);
                           RealWorld.all_keys := ... $+ (3, ekey 3) |},
                          {| IdealWorld.channel_vector := IdealWorld.addMsg ... ... ...; IdealWorld.users := ... $+ (2, ...) |},
                          true)] \cup
                      ([e
                       | exists y y0 : Map.key, ((...) /\ ... /\ ...) /\ e = ({| ...; ...; ...; ... |}, {| ...; ... |}, true)] \cup
                       ([e | exists y y0 : Map.key, (...) /\ e = ...] \cup ([e | exists ..., ...] \cup (... \cup ...))))))))))))))))) \cup
         ([e
          | exists y y0 : Map.key,
              ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
              e =
              ({|
               RealWorld.users := $0 $+ (0,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Return 1;
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 0, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (1,
                                  {|
                                  RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Send 2 (RealWorld.SignedCiphertext y0))
                                                          (fun _ : unit => RealWorld.Return 1);
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y0];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [];
                                  RealWorld.cur_nonce := 1 |}) $+ (2,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                          (fun voteC2 : RealWorld.crypto Nat =>
                                                           RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                             (fun vote1 : RealWorld.message.message Nat =>
                                                              RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                (fun vote2 : RealWorld.message.message Nat =>
                                                                 RealWorld.Return
                                                                   (if
                                                                     RealWorld.message.extractContent vote1 ==n
                                                                     RealWorld.message.extractContent vote2
                                                                    then RealWorld.message.extractContent vote1
                                                                    else 100))));
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y];
                                  RealWorld.from_nons := [(Some 0, 0)];
                                  RealWorld.sent_nons := [];
                                  RealWorld.cur_nonce := 0 |});
               RealWorld.adversary := {|
                                      RealWorld.key_heap := $0;
                                      RealWorld.protocol := RealWorld.Return tt;
                                      RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                      RealWorld.c_heap := [];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |};
               RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                        (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
               RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
              {|
              IdealWorld.channel_vector := IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1);
              IdealWorld.users := $0 $+ (0,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Send (IdealWorld.message.Content 1) (# 1);
                                                          IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                  {|
                                  IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                          m2 <- IdealWorld.Recv (# 1);
                                                          IdealWorld.Return
                                                            (if
                                                              IdealWorld.message.extractContent m1 ==n
                                                              IdealWorld.message.extractContent m2
                                                             then IdealWorld.message.extractContent m1
                                                             else 100))%idealworld;
                                  IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
          ([e
           | exists y y0 : Map.key,
               ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
               e =
               ({|
                RealWorld.users := $0 $+ (0,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Return 1;
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 0, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (1,
                                   {|
                                   RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                           (fun _ : unit => RealWorld.Return 1);
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y0];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 1, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (2,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                           (fun voteC1 : RealWorld.crypto Nat =>
                                                            RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                              (fun voteC2 : RealWorld.crypto Nat =>
                                                               RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                 (fun vote1 : RealWorld.message.message Nat =>
                                                                  RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                    (fun vote2 : RealWorld.message.message Nat =>
                                                                     RealWorld.Return
                                                                       (if
                                                                         RealWorld.message.extractContent vote1 ==n
                                                                         RealWorld.message.extractContent vote2
                                                                        then RealWorld.message.extractContent vote1
                                                                        else 100)))));
                                   RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                   RealWorld.c_heap := [y];
                                   RealWorld.from_nons := [(Some 0, 0)];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 0 |});
                RealWorld.adversary := {|
                                       RealWorld.key_heap := $0;
                                       RealWorld.protocol := RealWorld.Return tt;
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                             existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |};
                RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                         (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
               {|
               IdealWorld.channel_vector := IdealWorld.addMsg
                                              (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                 (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
               IdealWorld.users := $0 $+ (0,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                   {|
                                   IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                           m2 <- IdealWorld.Recv (# 1);
                                                           IdealWorld.Return
                                                             (if
                                                               IdealWorld.message.extractContent m1 ==n
                                                               IdealWorld.message.extractContent m2
                                                              then IdealWorld.message.extractContent m1
                                                              else 100))%idealworld;
                                   IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
           ([e
            | exists y y0 : Map.key,
                ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ True) /\
                e =
                ({|
                 RealWorld.users := $0 $+ (0,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Return 1;
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 0, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (1,
                                    {|
                                    RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Return 1;
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y0];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 1, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (2,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                            (fun voteC1 : RealWorld.crypto Nat =>
                                                             RealWorld.Bind
                                                               (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                               (fun voteC2 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                  (fun vote1 : RealWorld.message.message Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                                      RealWorld.Return
                                                                        (if
                                                                          RealWorld.message.extractContent vote1 ==n
                                                                          RealWorld.message.extractContent vote2
                                                                         then RealWorld.message.extractContent vote1
                                                                         else 100)))));
                                    RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                          existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                    RealWorld.c_heap := [];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |});
                 RealWorld.adversary := {|
                                        RealWorld.key_heap := $0;
                                        RealWorld.protocol := RealWorld.Return tt;
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                              existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |};
                 RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                          (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                 RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                {|
                IdealWorld.channel_vector := IdealWorld.addMsg
                                               (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                  (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                IdealWorld.users := $0 $+ (0,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                    {|
                                    IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                            m2 <- IdealWorld.Recv (# 1);
                                                            IdealWorld.Return
                                                              (if
                                                                IdealWorld.message.extractContent m1 ==n
                                                                IdealWorld.message.extractContent m2
                                                               then IdealWorld.message.extractContent m1
                                                               else 100))%idealworld;
                                    IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
            ([e
             | exists y y0 : Map.key,
                 ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 0 = # 1 -> False) /\ True) /\
                 e =
                 ({|
                  RealWorld.users := $0 $+ (0,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Return 1;
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 0, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (1,
                                     {|
                                     RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 1, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (2,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                             (fun voteC1 : RealWorld.crypto Nat =>
                                                              RealWorld.Bind
                                                                (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                (fun voteC2 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                   (fun vote1 : RealWorld.message.message Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                      (fun vote2 : RealWorld.message.message Nat =>
                                                                       RealWorld.Return (if ... then ... else 100)))));
                                     RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [(Some 0, 0)];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |});
                  RealWorld.adversary := {|
                                         RealWorld.key_heap := $0;
                                         RealWorld.protocol := RealWorld.Return tt;
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                               existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |};
                  RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                           (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                  RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                 {|
                 IdealWorld.channel_vector := IdealWorld.addMsg
                                                (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                   (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                 IdealWorld.users := $0 $+ (0,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                     {|
                                     IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                             m2 <- IdealWorld.Recv (# 1);
                                                             IdealWorld.Return
                                                               (if
                                                                 IdealWorld.message.extractContent m1 ==n
                                                                 IdealWorld.message.extractContent m2
                                                                then IdealWorld.message.extractContent m1
                                                                else 100))%idealworld;
                                     IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
             ([e
              | exists y y0 : Map.key,
                  ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
                  e =
                  ({|
                   RealWorld.users := $0 $+ (0,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 0, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (1,
                                      {|
                                      RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 1, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (2,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                              (fun voteC2 : RealWorld.crypto Nat =>
                                                               RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                 (fun vote1 : RealWorld.message.message Nat =>
                                                                  RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                    (fun vote2 : RealWorld.message.message Nat =>
                                                                     RealWorld.Return
                                                                       (if ... ==n ...
                                                                        then RealWorld.message.extractContent vote1
                                                                        else 100))));
                                      RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [(Some 0, 0)];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |});
                   RealWorld.adversary := {|
                                          RealWorld.key_heap := $0;
                                          RealWorld.protocol := RealWorld.Return tt;
                                          RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |};
                   RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                            (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                   RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                  {|
                  IdealWorld.channel_vector := IdealWorld.addMsg
                                                 (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                    (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                  IdealWorld.users := $0 $+ (0,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                      {|
                                      IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                              m2 <- IdealWorld.Recv (# 1);
                                                              IdealWorld.Return
                                                                (if
                                                                  IdealWorld.message.extractContent m1 ==n
                                                                  IdealWorld.message.extractContent m2
                                                                 then IdealWorld.message.extractContent m1
                                                                 else 100))%idealworld;
                                      IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
              ([e
               | exists y y0 : Map.key,
                   ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                               (fun _ : unit => RealWorld.Return 1);
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 0, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Return 1;
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 1, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                               (fun voteC1 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                  (fun voteC2 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                                      RealWorld.Bind (RealWorld.Decrypt voteC2) (... => ...))));
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [(Some 0, 0)];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                 existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := IdealWorld.addMsg
                                                  (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                     (# 0) (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                               m2 <- IdealWorld.Recv (# 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   IdealWorld.message.extractContent m1 ==n
                                                                   IdealWorld.message.extractContent m2
                                                                  then IdealWorld.message.extractContent m1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y y0 : Map.key,
                    ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 0 = # 1 -> False) /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Return 1;
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y0];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 1, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                (fun voteC1 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                   (fun voteC2 : RealWorld.crypto Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                      (fun ... => RealWorld.Bind ... ...)));
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [(Some 0, 0)];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                  existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                              (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg
                                                   (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 0) (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                m2 <- IdealWorld.Recv (# 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    IdealWorld.message.extractContent m1 ==n
                                                                    IdealWorld.message.extractContent m2
                                                                   then IdealWorld.message.extractContent m1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     ((y = y0 -> False) /\ incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Return 1;
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 0, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Return 1;
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 1, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 0 3 true))
                                                                 (fun voteC1 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                    (fun voteC2 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                               existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                   existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := IdealWorld.addMsg
                                                    (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                    (IdealWorld.message.Content 1);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m1 <- IdealWorld.Recv (# 0);
                                                                 m2 <- IdealWorld.Recv (# 1);
                                                                 IdealWorld.Return
                                                                   (if ... ==n ...
                                                                    then IdealWorld.message.extractContent m1
                                                                    else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y y0 : Map.key,
                      ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                  (fun ... => RealWorld.Return 1);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 0, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Return 1;
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 1, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                  (fun voteC1 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Recv ...) (... => ...));
                                          RealWorld.msg_heap := [existT (fun H : type => RealWorld.crypto H) Nat
                                                                   (RealWorld.SignedCiphertext y0)];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [(Some 0, 0)];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                    existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := IdealWorld.addMsg
                                                     (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                        (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                     (IdealWorld.message.Content 1);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                  m2 <- IdealWorld.Recv (# 1); IdealWorld.Return (... ... ...))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Return 1;
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 0, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (... => ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 1, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [existT (fun ... => RealWorld.crypto H) Nat
                                                                    (RealWorld.SignedCiphertext y0)];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [(Some 0, 0)];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                        (RealWorld.SignedCiphertext y0);
                                                                     existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg
                                                      (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                         (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                      (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m1 <- IdealWorld.Return (...);
                                                                   m2 <- IdealWorld.Recv ...; IdealWorld.Return ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   ([e
                    | exists y y0 : Map.key,
                        ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [...];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Bind ... ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [(..., 0)];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [existT (...) Nat (...)];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [(Some 0, 0)];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (...);
                                                                      existT RealWorld.crypto Nat (...)];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := IdealWorld.addMsg
                                                       (IdealWorld.addMsg (... #+ (# 1, [])) (# 1)
                                                          (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m1 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                    ([e
                     | exists y y0 : Map.key,
                         ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ True) /\
                         e =
                         ({|
                          RealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ...; ...; ...; ...; ...; ... |}) $+ (2,
                                             {|
                                             RealWorld.key_heap := ...;
                                             RealWorld.protocol := ...;
                                             RealWorld.msg_heap := ...;
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |});
                          RealWorld.adversary := {|
                                                 RealWorld.key_heap := $0;
                                                 RealWorld.protocol := RealWorld.Return tt;
                                                 RealWorld.msg_heap := [...; ...];
                                                 RealWorld.c_heap := [];
                                                 RealWorld.from_nons := [];
                                                 RealWorld.sent_nons := [];
                                                 RealWorld.cur_nonce := 0 |};
                          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 ... ...) $+ (y0,
                                                   RealWorld.SigEncCipher 0 3 2 (..., 0) (...));
                          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                         {|
                         IdealWorld.channel_vector := IdealWorld.addMsg (IdealWorld.addMsg ... ... ...) 
                                                        (# 0) (IdealWorld.message.Content 1);
                         IdealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ... |}) $+ (2,
                                             {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) |}, true)] \cup
                     ([e
                      | exists y y0 : Map.key,
                          ((y = y0 -> False) /\ (... -> False) /\ incl [y] [y] /\ ... /\ True) /\
                          e =
                          ({|
                           RealWorld.users := ... $+ (2, ...);
                           RealWorld.adversary := {| ...; ...; ...; ...; ...; ...; ... |};
                           RealWorld.all_ciphers := ... $+ (y0, ...);
                           RealWorld.all_keys := ... $+ (3, ekey 3) |},
                          {| IdealWorld.channel_vector := IdealWorld.addMsg ... ... ...; IdealWorld.users := ... $+ (2, ...) |},
                          true)] \cup
                      ([e
                       | exists y y0 : Map.key, ((...) /\ ... /\ ...) /\ e = ({| ...; ...; ...; ... |}, {| ...; ... |}, true)] \cup
                       ([e | exists y y0 : Map.key, (...) /\ e = ...] \cup ([e | exists ..., ...] \cup (... \cup ...)))))))))))))))))) \cup
        ([e
         | exists y y0 : Map.key,
             ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
             e =
             ({|
              RealWorld.users := $0 $+ (0,
                                 {|
                                 RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                 RealWorld.protocol := RealWorld.Return 1;
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [(Some 0, 0)];
                                 RealWorld.cur_nonce := 1 |}) $+ (1,
                                 {|
                                 RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                 RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y0];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [(Some 1, 0)];
                                 RealWorld.cur_nonce := 1 |}) $+ (2,
                                 {|
                                 RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                 RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                         (fun voteC2 : RealWorld.crypto Nat =>
                                                          RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                            (fun vote1 : RealWorld.message.message Nat =>
                                                             RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                               (fun vote2 : RealWorld.message.message Nat =>
                                                                RealWorld.Return
                                                                  (if
                                                                    RealWorld.message.extractContent vote1 ==n
                                                                    RealWorld.message.extractContent vote2
                                                                   then RealWorld.message.extractContent vote1
                                                                   else 100))));
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                 RealWorld.c_heap := [y];
                                 RealWorld.from_nons := [(Some 0, 0)];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |});
              RealWorld.adversary := {|
                                     RealWorld.key_heap := $0;
                                     RealWorld.protocol := RealWorld.Return tt;
                                     RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                           existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                     RealWorld.c_heap := [];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |};
              RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                       RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
              RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
             {|
             IdealWorld.channel_vector := IdealWorld.addMsg
                                            (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                               (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
             IdealWorld.users := $0 $+ (0,
                                 {|
                                 IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                 IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                 {|
                                 IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                 IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                 {|
                                 IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                         m2 <- IdealWorld.Recv (# 1);
                                                         IdealWorld.Return
                                                           (if
                                                             IdealWorld.message.extractContent m1 ==n
                                                             IdealWorld.message.extractContent m2
                                                            then IdealWorld.message.extractContent m1
                                                            else 100))%idealworld;
                                 IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
         ([e
          | exists y y0 : Map.key,
              ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
              e =
              ({|
               RealWorld.users := $0 $+ (0,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Return 1;
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 0, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (1,
                                  {|
                                  RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Return 1;
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y0];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 1, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (2,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                          (fun voteC1 : RealWorld.crypto Nat =>
                                                           RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                             (fun voteC2 : RealWorld.crypto Nat =>
                                                              RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                (fun vote1 : RealWorld.message.message Nat =>
                                                                 RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                   (fun vote2 : RealWorld.message.message Nat =>
                                                                    RealWorld.Return
                                                                      (if
                                                                        RealWorld.message.extractContent vote1 ==n
                                                                        RealWorld.message.extractContent vote2
                                                                       then RealWorld.message.extractContent vote1
                                                                       else 100)))));
                                  RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                  RealWorld.c_heap := [y];
                                  RealWorld.from_nons := [(Some 0, 0)];
                                  RealWorld.sent_nons := [];
                                  RealWorld.cur_nonce := 0 |});
               RealWorld.adversary := {|
                                      RealWorld.key_heap := $0;
                                      RealWorld.protocol := RealWorld.Return tt;
                                      RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                            existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                      RealWorld.c_heap := [];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |};
               RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                        (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
               RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
              {|
              IdealWorld.channel_vector := IdealWorld.addMsg
                                             (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
              IdealWorld.users := $0 $+ (0,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                  {|
                                  IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                          m2 <- IdealWorld.Recv (# 1);
                                                          IdealWorld.Return
                                                            (if
                                                              IdealWorld.message.extractContent m1 ==n
                                                              IdealWorld.message.extractContent m2
                                                             then IdealWorld.message.extractContent m1
                                                             else 100))%idealworld;
                                  IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
          ([e
           | exists y y0 : Map.key,
               ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 0 = # 1 -> False) /\ True) /\
               e =
               ({|
                RealWorld.users := $0 $+ (0,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Return 1;
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 0, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (1,
                                   {|
                                   RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Return 1;
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y0];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 1, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (2,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                           (fun voteC1 : RealWorld.crypto Nat =>
                                                            RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                              (fun voteC2 : RealWorld.crypto Nat =>
                                                               RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                 (fun vote1 : RealWorld.message.message Nat =>
                                                                  RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                    (fun vote2 : RealWorld.message.message Nat =>
                                                                     RealWorld.Return
                                                                       (if
                                                                         RealWorld.message.extractContent vote1 ==n
                                                                         RealWorld.message.extractContent vote2
                                                                        then RealWorld.message.extractContent vote1
                                                                        else 100)))));
                                   RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                   RealWorld.c_heap := [y];
                                   RealWorld.from_nons := [(Some 0, 0)];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 0 |});
                RealWorld.adversary := {|
                                       RealWorld.key_heap := $0;
                                       RealWorld.protocol := RealWorld.Return tt;
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                             existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |};
                RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                         (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
               {|
               IdealWorld.channel_vector := IdealWorld.addMsg
                                              (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                 (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
               IdealWorld.users := $0 $+ (0,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                   {|
                                   IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                           m2 <- IdealWorld.Recv (# 1);
                                                           IdealWorld.Return
                                                             (if
                                                               IdealWorld.message.extractContent m1 ==n
                                                               IdealWorld.message.extractContent m2
                                                              then IdealWorld.message.extractContent m1
                                                              else 100))%idealworld;
                                   IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
           ([e
            | exists y y0 : Map.key,
                ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
                e =
                ({|
                 RealWorld.users := $0 $+ (0,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                            (fun _ : unit => RealWorld.Return 1);
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 0, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (1,
                                    {|
                                    RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Return 1;
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y0];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 1, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (2,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                            (fun voteC2 : RealWorld.crypto Nat =>
                                                             RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                               (fun vote1 : RealWorld.message.message Nat =>
                                                                RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                  (fun vote2 : RealWorld.message.message Nat =>
                                                                   RealWorld.Return
                                                                     (if
                                                                       RealWorld.message.extractContent vote1 ==n
                                                                       RealWorld.message.extractContent vote2
                                                                      then RealWorld.message.extractContent vote1
                                                                      else 100))));
                                    RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                    RealWorld.c_heap := [y];
                                    RealWorld.from_nons := [(Some 0, 0)];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |});
                 RealWorld.adversary := {|
                                        RealWorld.key_heap := $0;
                                        RealWorld.protocol := RealWorld.Return tt;
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                              existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |};
                 RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                          (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                 RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                {|
                IdealWorld.channel_vector := IdealWorld.addMsg
                                               (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                  (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                IdealWorld.users := $0 $+ (0,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                    {|
                                    IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                            m2 <- IdealWorld.Recv (# 1);
                                                            IdealWorld.Return
                                                              (if
                                                                IdealWorld.message.extractContent m1 ==n
                                                                IdealWorld.message.extractContent m2
                                                               then IdealWorld.message.extractContent m1
                                                               else 100))%idealworld;
                                    IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
            ([e
             | exists y y0 : Map.key,
                 ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
                 e =
                 ({|
                  RealWorld.users := $0 $+ (0,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 0, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (1,
                                     {|
                                     RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 1, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (2,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                             (fun voteC2 : RealWorld.crypto Nat =>
                                                              RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                (fun vote1 : RealWorld.message.message Nat =>
                                                                 RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                   (fun vote2 : RealWorld.message.message Nat =>
                                                                    RealWorld.Return
                                                                      (if
                                                                        RealWorld.message.extractContent vote1 ==n
                                                                        RealWorld.message.extractContent vote2
                                                                       then RealWorld.message.extractContent vote1
                                                                       else 100))));
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0; y];
                                     RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |});
                  RealWorld.adversary := {|
                                         RealWorld.key_heap := $0;
                                         RealWorld.protocol := RealWorld.Return tt;
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                               existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |};
                  RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                           (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                  RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                 {|
                 IdealWorld.channel_vector := IdealWorld.addMsg
                                                (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                   (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                 IdealWorld.users := $0 $+ (0,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                     {|
                                     IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                             IdealWorld.Return
                                                               (if
                                                                 match
                                                                   IdealWorld.message.extractContent m2 as n
                                                                   return ({1 = n} + {1 = n -> False})
                                                                 with
                                                                 | 0 =>
                                                                     right
                                                                       (fun H : 1 = 0 =>
                                                                        match H in ... return ... with
                                                                        | eq_refl => fun ... => False_ind False ...
                                                                        end eq_refl)
                                                                 | S m =>
                                                                     match
                                                                       match m as n return ... with
                                                                       | 0 => left eq_refl
                                                                       | S m0 => right (...)
                                                                       end
                                                                     with
                                                                     | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                     | right n0 => right (not_eq_S 0 m n0)
                                                                     end
                                                                 end
                                                                then 1
                                                                else 100))%idealworld;
                                     IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
             ([e
              | exists y y0 : Map.key,
                  ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                  e =
                  ({|
                   RealWorld.users := $0 $+ (0,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Return 1;
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 0, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (1,
                                      {|
                                      RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Return 1;
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 1, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (2,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                              (fun voteC1 : RealWorld.crypto Nat =>
                                                               RealWorld.Bind
                                                                 (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                 (fun voteC2 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind (RealWorld.Decrypt voteC1)
                                                                    (fun vote1 : RealWorld.message.message Nat =>
                                                                     RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                       (fun vote2 : ... => RealWorld.Return (...)))));
                                      RealWorld.msg_heap := [existT (fun H : type => RealWorld.crypto H) Nat
                                                               (RealWorld.SignedCiphertext y0)];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [(Some 0, 0)];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |});
                   RealWorld.adversary := {|
                                          RealWorld.key_heap := $0;
                                          RealWorld.protocol := RealWorld.Return tt;
                                          RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |};
                   RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                            (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                   RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                  {|
                  IdealWorld.channel_vector := IdealWorld.addMsg
                                                 (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                    (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                  IdealWorld.users := $0 $+ (0,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                      {|
                                      IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                              m2 <- IdealWorld.Recv (# 1);
                                                              IdealWorld.Return
                                                                (if
                                                                  IdealWorld.message.extractContent m1 ==n
                                                                  IdealWorld.message.extractContent m2
                                                                 then IdealWorld.message.extractContent m1
                                                                 else 100))%idealworld;
                                      IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
              ([e
               | exists y y0 : Map.key,
                   ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                               (fun _ : unit => RealWorld.Return 1);
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 0, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Return 1;
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 1, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind
                                                               (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                               (fun voteC2 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                  (fun vote1 : RealWorld.message.message Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                                      RealWorld.Return (... ... ...))));
                                       RealWorld.msg_heap := [existT (fun H : type => RealWorld.crypto H) Nat
                                                                (RealWorld.SignedCiphertext y0)];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [(Some 0, 0)];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                 existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := IdealWorld.addMsg
                                                  (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                     (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                               m2 <- IdealWorld.Recv (# 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   IdealWorld.message.extractContent m1 ==n
                                                                   IdealWorld.message.extractContent m2
                                                                  then IdealWorld.message.extractContent m1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y y0 : Map.key,
                    ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Return 1;
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y0];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 1, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind
                                                                (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                (fun voteC2 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                   (fun vote1 : RealWorld.message.message Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                      (fun ... => RealWorld.Return ...)));
                                        RealWorld.msg_heap := [existT (fun H : type => RealWorld.crypto H) Nat
                                                                 (RealWorld.SignedCiphertext y0)];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [(Some 0, 0)];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                  existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                              (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg
                                                   (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                m2 <- IdealWorld.Recv (# 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    IdealWorld.message.extractContent m1 ==n
                                                                    IdealWorld.message.extractContent m2
                                                                   then IdealWorld.message.extractContent m1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                 (fun _ : unit => RealWorld.Return 1);
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 0, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                 (fun _ : unit => RealWorld.Return 1);
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 1, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                                 (fun voteC2 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                    (fun vote1 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0; y];
                                         RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                   existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := IdealWorld.addMsg
                                                    (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                    (IdealWorld.message.Content 1);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                 IdealWorld.Return
                                                                   (if match ... with
                                                                       | ... ...
                                                                       | ... ...
                                                                       end then 1 else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y y0 : Map.key,
                      ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Return 1;
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 0, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Return 1;
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 1, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind
                                                                  (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                                  (fun voteC1 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Recv ...) (... => ...));
                                          RealWorld.msg_heap := [existT (fun H : type => RealWorld.crypto H) Nat
                                                                   (RealWorld.SignedCiphertext y)];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [(Some 0, 0)];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                    existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := IdealWorld.addMsg
                                                     (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                        (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                     (IdealWorld.message.Content 1);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                  m2 <- IdealWorld.Recv (# 1); IdealWorld.Return (... ... ...))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (...) (...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 0, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Return 1;
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 1, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [existT (fun ... => RealWorld.crypto H) Nat
                                                                    (RealWorld.SignedCiphertext y)];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [(Some 0, 0)];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                     existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg
                                                      (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                         (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                      (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m1 <- IdealWorld.Return (...);
                                                                   m2 <- IdealWorld.Recv ...; IdealWorld.Return ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   ([e
                    | exists y y0 : Map.key,
                        ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [...];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Bind ... ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [(..., 0)];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [existT (...) Nat (...)];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [(Some 0, 0)];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (...);
                                                                      existT RealWorld.crypto Nat (...)];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := IdealWorld.addMsg
                                                       (IdealWorld.addMsg (... #+ (# 1, [])) (# 1)
                                                          (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m1 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                    ([e
                     | exists y y0 : Map.key,
                         ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (... -> False) /\ (...) /\ True) /\
                         e =
                         ({|
                          RealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ...; ...; ...; ...; ...; ... |}) $+ (2,
                                             {|
                                             RealWorld.key_heap := ...;
                                             RealWorld.protocol := ...;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := ...;
                                             RealWorld.from_nons := ...;
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |});
                          RealWorld.adversary := {|
                                                 RealWorld.key_heap := $0;
                                                 RealWorld.protocol := RealWorld.Return tt;
                                                 RealWorld.msg_heap := [...; ...];
                                                 RealWorld.c_heap := [];
                                                 RealWorld.from_nons := [];
                                                 RealWorld.sent_nons := [];
                                                 RealWorld.cur_nonce := 0 |};
                          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 ... ...) $+ (y0,
                                                   RealWorld.SigEncCipher 0 3 2 (..., 0) (...));
                          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                         {|
                         IdealWorld.channel_vector := IdealWorld.addMsg (IdealWorld.addMsg ... ... ...) 
                                                        (# 0) (IdealWorld.message.Content 1);
                         IdealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ... |}) $+ (2,
                                             {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) |}, true)] \cup
                     ([e
                      | exists y y0 : Map.key,
                          ((y = y0 -> False) /\ incl [y0] [y0] /\ (...) /\ ... /\ True) /\
                          e =
                          ({|
                           RealWorld.users := ... $+ (2, ...);
                           RealWorld.adversary := {| ...; ...; ...; ...; ...; ...; ... |};
                           RealWorld.all_ciphers := ... $+ (y0, ...);
                           RealWorld.all_keys := ... $+ (3, ekey 3) |},
                          {| IdealWorld.channel_vector := IdealWorld.addMsg ... ... ...; IdealWorld.users := ... $+ (2, ...) |},
                          true)] \cup
                      ([e
                       | exists y y0 : Map.key, ((...) /\ ... /\ ...) /\ e = ({| ...; ...; ...; ... |}, {| ...; ... |}, true)] \cup
                       ([e | exists y y0 : Map.key, (...) /\ e = ...] \cup ([e | exists ..., ...] \cup [e | exists ..., ...])))))))))))))))))) \cup
       ([e
        | exists y y0 : Map.key,
            ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
            e =
            ({|
             RealWorld.users := $0 $+ (0,
                                {|
                                RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                RealWorld.protocol := RealWorld.Return 1;
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [(Some 0, 0)];
                                RealWorld.cur_nonce := 1 |}) $+ (1,
                                {|
                                RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                RealWorld.protocol := RealWorld.Return 1;
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y0];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [(Some 1, 0)];
                                RealWorld.cur_nonce := 1 |}) $+ (2,
                                {|
                                RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                        (fun voteC2 : RealWorld.crypto Nat =>
                                                         RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                           (fun vote1 : RealWorld.message.message Nat =>
                                                            RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                              (fun vote2 : RealWorld.message.message Nat =>
                                                               RealWorld.Return
                                                                 (if
                                                                   RealWorld.message.extractContent vote1 ==n
                                                                   RealWorld.message.extractContent vote2
                                                                  then RealWorld.message.extractContent vote1
                                                                  else 100))));
                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                RealWorld.c_heap := [y];
                                RealWorld.from_nons := [(Some 0, 0)];
                                RealWorld.sent_nons := [];
                                RealWorld.cur_nonce := 0 |});
             RealWorld.adversary := {|
                                    RealWorld.key_heap := $0;
                                    RealWorld.protocol := RealWorld.Return tt;
                                    RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                          existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                    RealWorld.c_heap := [];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |};
             RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                      RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
             RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
            {|
            IdealWorld.channel_vector := IdealWorld.addMsg
                                           (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                              (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
            IdealWorld.users := $0 $+ (0,
                                {|
                                IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                {|
                                IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                {|
                                IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                        m2 <- IdealWorld.Recv (# 1);
                                                        IdealWorld.Return
                                                          (if
                                                            IdealWorld.message.extractContent m1 ==n
                                                            IdealWorld.message.extractContent m2
                                                           then IdealWorld.message.extractContent m1
                                                           else 100))%idealworld;
                                IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
        ([e
         | exists y y0 : Map.key,
             ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
             e =
             ({|
              RealWorld.users := $0 $+ (0,
                                 {|
                                 RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                 RealWorld.protocol := RealWorld.Return 1;
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [(Some 0, 0)];
                                 RealWorld.cur_nonce := 1 |}) $+ (1,
                                 {|
                                 RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                 RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y0];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [(Some 1, 0)];
                                 RealWorld.cur_nonce := 1 |}) $+ (2,
                                 {|
                                 RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                 RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                         (fun voteC2 : RealWorld.crypto Nat =>
                                                          RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                            (fun vote1 : RealWorld.message.message Nat =>
                                                             RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                               (fun vote2 : RealWorld.message.message Nat =>
                                                                RealWorld.Return
                                                                  (if
                                                                    RealWorld.message.extractContent vote1 ==n
                                                                    RealWorld.message.extractContent vote2
                                                                   then RealWorld.message.extractContent vote1
                                                                   else 100))));
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y0; y];
                                 RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |});
              RealWorld.adversary := {|
                                     RealWorld.key_heap := $0;
                                     RealWorld.protocol := RealWorld.Return tt;
                                     RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                           existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                     RealWorld.c_heap := [];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |};
              RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                       RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
              RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
             {|
             IdealWorld.channel_vector := IdealWorld.addMsg
                                            (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                               (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
             IdealWorld.users := $0 $+ (0,
                                 {|
                                 IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                 IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                 {|
                                 IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                 IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                 {|
                                 IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                         IdealWorld.Return
                                                           (if
                                                             match
                                                               IdealWorld.message.extractContent m2 as n
                                                               return ({1 = n} + {1 = n -> False})
                                                             with
                                                             | 0 =>
                                                                 right
                                                                   (fun H : 1 = 0 =>
                                                                    match H in (_ = y1) return (y1 = 0 -> False) with
                                                                    | eq_refl =>
                                                                        fun H0 : 1 = 0 =>
                                                                        False_ind False
                                                                          (eq_ind 1
                                                                             (fun e0 : nat =>
                                                                              match e0 with
                                                                              | 0 => False
                                                                              | S _ => True
                                                                              end) I 0 H0)
                                                                    end eq_refl)
                                                             | S m =>
                                                                 match
                                                                   match m as n return ({0 = n} + {0 = n -> False}) with
                                                                   | 0 => left eq_refl
                                                                   | S m0 => right (O_S m0)
                                                                   end
                                                                 with
                                                                 | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                 | right n0 => right (not_eq_S 0 m n0)
                                                                 end
                                                             end
                                                            then 1
                                                            else 100))%idealworld;
                                 IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
         ([e
          | exists y y0 : Map.key,
              ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
              e =
              ({|
               RealWorld.users := $0 $+ (0,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                          (fun _ : unit => RealWorld.Return 1);
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 0, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (1,
                                  {|
                                  RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Return 1;
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y0];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 1, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (2,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                          (fun voteC2 : RealWorld.crypto Nat =>
                                                           RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                             (fun vote1 : RealWorld.message.message Nat =>
                                                              RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                (fun vote2 : RealWorld.message.message Nat =>
                                                                 RealWorld.Return
                                                                   (if
                                                                     RealWorld.message.extractContent vote1 ==n
                                                                     RealWorld.message.extractContent vote2
                                                                    then RealWorld.message.extractContent vote1
                                                                    else 100))));
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y0; y];
                                  RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                  RealWorld.sent_nons := [];
                                  RealWorld.cur_nonce := 0 |});
               RealWorld.adversary := {|
                                      RealWorld.key_heap := $0;
                                      RealWorld.protocol := RealWorld.Return tt;
                                      RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                            existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                      RealWorld.c_heap := [];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |};
               RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                        (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
               RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
              {|
              IdealWorld.channel_vector := IdealWorld.addMsg
                                             (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
              IdealWorld.users := $0 $+ (0,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                  {|
                                  IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                          IdealWorld.Return
                                                            (if
                                                              match
                                                                IdealWorld.message.extractContent m2 as n
                                                                return ({1 = n} + {1 = n -> False})
                                                              with
                                                              | 0 =>
                                                                  right
                                                                    (fun H : 1 = 0 =>
                                                                     match H in (_ = y1) return (y1 = 0 -> False) with
                                                                     | eq_refl =>
                                                                         fun H0 : 1 = 0 =>
                                                                         False_ind False
                                                                           (eq_ind 1
                                                                              (fun e0 : nat =>
                                                                               match ... with
                                                                               | ... False
                                                                               | ... True
                                                                               end) I 0 H0)
                                                                     end eq_refl)
                                                              | S m =>
                                                                  match
                                                                    match m as n return ({0 = n} + {0 = n -> False}) with
                                                                    | 0 => left eq_refl
                                                                    | S m0 => right (O_S m0)
                                                                    end
                                                                  with
                                                                  | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                  | right n0 => right (not_eq_S 0 m n0)
                                                                  end
                                                              end
                                                             then 1
                                                             else 100))%idealworld;
                                  IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
          ([e
           | exists y y0 : Map.key,
               ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
               e =
               ({|
                RealWorld.users := $0 $+ (0,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                           (fun _ : unit => RealWorld.Return 1);
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 0, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (1,
                                   {|
                                   RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                           (fun _ : unit => RealWorld.Return 1);
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y0];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 1, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (2,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                           (fun vote1 : RealWorld.message.message Nat =>
                                                            RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                              (fun vote2 : RealWorld.message.message Nat =>
                                                               RealWorld.Return
                                                                 (if
                                                                   RealWorld.message.extractContent vote1 ==n
                                                                   RealWorld.message.extractContent vote2
                                                                  then RealWorld.message.extractContent vote1
                                                                  else 100)));
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y0; y];
                                   RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 0 |});
                RealWorld.adversary := {|
                                       RealWorld.key_heap := $0;
                                       RealWorld.protocol := RealWorld.Return tt;
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                             existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |};
                RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                         (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
               {|
               IdealWorld.channel_vector := IdealWorld.addMsg
                                              (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                 (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
               IdealWorld.users := $0 $+ (0,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                   {|
                                   IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                           IdealWorld.Return
                                                             (if
                                                               match
                                                                 IdealWorld.message.extractContent m2 as n
                                                                 return ({1 = n} + {1 = n -> False})
                                                               with
                                                               | 0 =>
                                                                   right
                                                                     (fun H : 1 = 0 =>
                                                                      match H in (_ = y1) return (y1 = 0 -> False) with
                                                                      | eq_refl =>
                                                                          fun H0 : 1 = 0 =>
                                                                          False_ind False (eq_ind 1 (... => ...) I 0 H0)
                                                                      end eq_refl)
                                                               | S m =>
                                                                   match
                                                                     match m as n return ({0 = n} + {0 = n -> False}) with
                                                                     | 0 => left eq_refl
                                                                     | S m0 => right (O_S m0)
                                                                     end
                                                                   with
                                                                   | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                   | right n0 => right (not_eq_S 0 m n0)
                                                                   end
                                                               end
                                                              then 1
                                                              else 100))%idealworld;
                                   IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
           ([e
            | exists y y0 : Map.key,
                ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                e =
                ({|
                 RealWorld.users := $0 $+ (0,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Return 1;
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 0, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (1,
                                    {|
                                    RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Return 1;
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y0];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 1, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (2,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                            (fun voteC2 : RealWorld.crypto Nat =>
                                                             RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                               (fun vote1 : RealWorld.message.message Nat =>
                                                                RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                  (fun vote2 : RealWorld.message.message Nat =>
                                                                   RealWorld.Return
                                                                     (if
                                                                       RealWorld.message.extractContent vote1 ==n
                                                                       RealWorld.message.extractContent vote2
                                                                      then RealWorld.message.extractContent vote1
                                                                      else 100))));
                                    RealWorld.msg_heap := [existT (fun H : type => RealWorld.crypto H) Nat
                                                             (RealWorld.SignedCiphertext y0)];
                                    RealWorld.c_heap := [y];
                                    RealWorld.from_nons := [(Some 0, 0)];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |});
                 RealWorld.adversary := {|
                                        RealWorld.key_heap := $0;
                                        RealWorld.protocol := RealWorld.Return tt;
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                              existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |};
                 RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                          (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                 RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                {|
                IdealWorld.channel_vector := IdealWorld.addMsg
                                               (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                  (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                IdealWorld.users := $0 $+ (0,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                    {|
                                    IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                            m2 <- IdealWorld.Recv (# 1);
                                                            IdealWorld.Return
                                                              (if
                                                                IdealWorld.message.extractContent m1 ==n
                                                                IdealWorld.message.extractContent m2
                                                               then IdealWorld.message.extractContent m1
                                                               else 100))%idealworld;
                                    IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
            ([e
             | exists y y0 : Map.key,
                 ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                 e =
                 ({|
                  RealWorld.users := $0 $+ (0,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 0, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (1,
                                     {|
                                     RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Return 1;
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 1, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (2,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                             (fun voteC2 : RealWorld.crypto Nat =>
                                                              RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                (fun vote1 : RealWorld.message.message Nat =>
                                                                 RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                   (fun vote2 : RealWorld.message.message Nat =>
                                                                    RealWorld.Return
                                                                      (if
                                                                        RealWorld.message.extractContent vote1 ==n
                                                                        RealWorld.message.extractContent vote2
                                                                       then RealWorld.message.extractContent vote1
                                                                       else 100))));
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0; y];
                                     RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |});
                  RealWorld.adversary := {|
                                         RealWorld.key_heap := $0;
                                         RealWorld.protocol := RealWorld.Return tt;
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                               existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |};
                  RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                           (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                  RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                 {|
                 IdealWorld.channel_vector := IdealWorld.addMsg
                                                (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                   (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                 IdealWorld.users := $0 $+ (0,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                     {|
                                     IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                             IdealWorld.Return
                                                               (if
                                                                 match
                                                                   IdealWorld.message.extractContent m2 as n
                                                                   return ({1 = n} + {1 = n -> False})
                                                                 with
                                                                 | 0 =>
                                                                     right
                                                                       (fun H : 1 = 0 =>
                                                                        match H in ... return ... with
                                                                        | eq_refl => fun ... => False_ind False ...
                                                                        end eq_refl)
                                                                 | S m =>
                                                                     match
                                                                       match m as n return ... with
                                                                       | 0 => left eq_refl
                                                                       | S m0 => right (...)
                                                                       end
                                                                     with
                                                                     | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                     | right n0 => right (not_eq_S 0 m n0)
                                                                     end
                                                                 end
                                                                then 1
                                                                else 100))%idealworld;
                                     IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
             ([e
              | exists y y0 : Map.key,
                  ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                  e =
                  ({|
                   RealWorld.users := $0 $+ (0,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Return 1;
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 0, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (1,
                                      {|
                                      RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 1, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (2,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                              (fun voteC2 : RealWorld.crypto Nat =>
                                                               RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                 (fun vote1 : RealWorld.message.message Nat =>
                                                                  RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                    (fun vote2 : RealWorld.message.message Nat =>
                                                                     RealWorld.Return
                                                                       (if ... ==n ...
                                                                        then RealWorld.message.extractContent vote1
                                                                        else 100))));
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0; y];
                                      RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |});
                   RealWorld.adversary := {|
                                          RealWorld.key_heap := $0;
                                          RealWorld.protocol := RealWorld.Return tt;
                                          RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |};
                   RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                            (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                   RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                  {|
                  IdealWorld.channel_vector := IdealWorld.addMsg
                                                 (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                    (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                  IdealWorld.users := $0 $+ (0,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                      {|
                                      IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                              IdealWorld.Return
                                                                (if
                                                                  match
                                                                    IdealWorld.message.extractContent m2 as n
                                                                    return ({1 = n} + {1 = n -> False})
                                                                  with
                                                                  | 0 =>
                                                                      right
                                                                        (fun H : 1 = 0 => match ... with
                                                                                          | ... ...
                                                                                          end eq_refl)
                                                                  | S m =>
                                                                      match match ... with
                                                                            | ... ...
                                                                            | ... ...
                                                                            end with
                                                                      | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                      | right n0 => right (not_eq_S 0 m n0)
                                                                      end
                                                                  end
                                                                 then 1
                                                                 else 100))%idealworld;
                                      IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
              ([e
               | exists y y0 : Map.key,
                   ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                               (fun _ : unit => RealWorld.Return 1);
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 0, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                               (fun _ : unit => RealWorld.Return 1);
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 1, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                               (fun vote1 : RealWorld.message.message Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                                  (fun vote2 : RealWorld.message.message Nat =>
                                                                   RealWorld.Return
                                                                     (if
                                                                       RealWorld.message.extractContent vote1 ==n
                                                                       RealWorld.message.extractContent vote2
                                                                      then RealWorld.message.extractContent vote1
                                                                      else 100)));
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0; y];
                                       RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                 existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := IdealWorld.addMsg
                                                  (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                     (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   match
                                                                     IdealWorld.message.extractContent m2 as n
                                                                     return ({...} + {...})
                                                                   with
                                                                   | 0 => right (fun ... => ... eq_refl)
                                                                   | S m =>
                                                                       match ... with
                                                                       | left e0 => left (...)
                                                                       | right n0 => right (...)
                                                                       end
                                                                   end
                                                                  then 1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y y0 : Map.key,
                    ((y = y0 -> False) /\ (y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Return 1;
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y0];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Return 1;
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 1, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind
                                                                (RealWorld.Recv (RealWorld.SignedEncrypted 1 3 true))
                                                                (fun voteC2 : RealWorld.crypto Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                                   (fun vote1 : RealWorld.message.message Nat =>
                                                                    RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                      (fun ... => RealWorld.Return ...)));
                                        RealWorld.msg_heap := [existT (fun H : type => RealWorld.crypto H) Nat
                                                                 (RealWorld.SignedCiphertext y)];
                                        RealWorld.c_heap := [y0];
                                        RealWorld.from_nons := [(Some 0, 0)];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                  existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                              (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg
                                                   (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m1 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                m2 <- IdealWorld.Recv (# 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    IdealWorld.message.extractContent m1 ==n
                                                                    IdealWorld.message.extractContent m2
                                                                   then IdealWorld.message.extractContent m1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                 (fun _ : unit => RealWorld.Return 1);
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 0, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Return 1;
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 1, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                 (fun voteC2 : RealWorld.crypto Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                                    (fun vote1 : ... => RealWorld.Bind (...) (...)));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y; y0];
                                         RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                   existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := IdealWorld.addMsg
                                                    (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                    (IdealWorld.message.Content 1);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                 IdealWorld.Return
                                                                   (if match ... with
                                                                       | ... ...
                                                                       | ... ...
                                                                       end then 1 else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y y0 : Map.key,
                      ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Return 1;
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 0, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                  (fun _ : unit => RealWorld.Return 1);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 1, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                                  (fun voteC2 : RealWorld.crypto Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt ...) (... => ...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y; y0];
                                          RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                    existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := IdealWorld.addMsg
                                                     (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                        (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                     (IdealWorld.message.Content 1);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                  IdealWorld.Return (if ... then 1 else 100))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (...) (...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 0, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (... => ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 1, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y; y0];
                                           RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                     existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg
                                                      (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                         (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                      (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m2 <- IdealWorld.Return (...); IdealWorld.Return (...))%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   ([e
                    | exists y y0 : Map.key,
                        ((y = y0 -> False) /\ incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [...];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Return 1;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [(..., 0)];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (...)];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [(Some 0, 0)];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (...);
                                                                      existT RealWorld.crypto Nat (...)];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := IdealWorld.addMsg
                                                       (IdealWorld.addMsg (... #+ (# 1, [])) (# 0)
                                                          (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m1 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                    ([e
                     | exists y y0 : Map.key,
                         ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (... -> False) /\ True) /\
                         e =
                         ({|
                          RealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ...; ...; ...; ...; ...; ... |}) $+ (2,
                                             {|
                                             RealWorld.key_heap := ...;
                                             RealWorld.protocol := ...;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := ...;
                                             RealWorld.from_nons := ...;
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |});
                          RealWorld.adversary := {|
                                                 RealWorld.key_heap := $0;
                                                 RealWorld.protocol := RealWorld.Return tt;
                                                 RealWorld.msg_heap := [...; ...];
                                                 RealWorld.c_heap := [];
                                                 RealWorld.from_nons := [];
                                                 RealWorld.sent_nons := [];
                                                 RealWorld.cur_nonce := 0 |};
                          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 ... ...) $+ (y0,
                                                   RealWorld.SigEncCipher 0 3 2 (..., 0) (...));
                          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                         {|
                         IdealWorld.channel_vector := IdealWorld.addMsg (IdealWorld.addMsg ... ... ...) 
                                                        (# 1) (IdealWorld.message.Content 1);
                         IdealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ... |}) $+ (2,
                                             {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) |}, true)] \cup
                     ([e
                      | exists y y0 : Map.key,
                          ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ ... /\ True) /\
                          e =
                          ({|
                           RealWorld.users := ... $+ (2, ...);
                           RealWorld.adversary := {| ...; ...; ...; ...; ...; ...; ... |};
                           RealWorld.all_ciphers := ... $+ (y0, ...);
                           RealWorld.all_keys := ... $+ (3, ekey 3) |},
                          {| IdealWorld.channel_vector := IdealWorld.addMsg ... ... ...; IdealWorld.users := ... $+ (2, ...) |},
                          true)] \cup
                      [e
                      | exists y y0 : Map.key,
                          ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ ... /\ True) /\
                          e =
                          ({|
                           RealWorld.users := ... $+ (2, ...);
                           RealWorld.adversary := {| ...; ...; ...; ...; ...; ...; ... |};
                           RealWorld.all_ciphers := ... $+ (y0, ...);
                           RealWorld.all_keys := ... $+ (3, ekey 3) |},
                          {| IdealWorld.channel_vector := IdealWorld.addMsg ... ... ...; IdealWorld.users := ... $+ (2, ...) |},
                          true)])))))))))))))))) \cup
      ([e
       | exists y y0 : Map.key,
           ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
           e =
           ({|
            RealWorld.users := $0 $+ (0,
                               {|
                               RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                               RealWorld.protocol := RealWorld.Return 1;
                               RealWorld.msg_heap := [];
                               RealWorld.c_heap := [y];
                               RealWorld.from_nons := [];
                               RealWorld.sent_nons := [(Some 0, 0)];
                               RealWorld.cur_nonce := 1 |}) $+ (1,
                               {|
                               RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                               RealWorld.protocol := RealWorld.Return 1;
                               RealWorld.msg_heap := [];
                               RealWorld.c_heap := [y0];
                               RealWorld.from_nons := [];
                               RealWorld.sent_nons := [(Some 1, 0)];
                               RealWorld.cur_nonce := 1 |}) $+ (2,
                               {|
                               RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                               RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                       (fun voteC2 : RealWorld.crypto Nat =>
                                                        RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                          (fun vote1 : RealWorld.message.message Nat =>
                                                           RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                             (fun vote2 : RealWorld.message.message Nat =>
                                                              RealWorld.Return
                                                                (if
                                                                  RealWorld.message.extractContent vote1 ==n
                                                                  RealWorld.message.extractContent vote2
                                                                 then RealWorld.message.extractContent vote1
                                                                 else 100))));
                               RealWorld.msg_heap := [];
                               RealWorld.c_heap := [y0; y];
                               RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                               RealWorld.sent_nons := [];
                               RealWorld.cur_nonce := 0 |});
            RealWorld.adversary := {|
                                   RealWorld.key_heap := $0;
                                   RealWorld.protocol := RealWorld.Return tt;
                                   RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                         existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                   RealWorld.c_heap := [];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 0 |};
            RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                     RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
            RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
           {|
           IdealWorld.channel_vector := IdealWorld.addMsg
                                          (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                          (# 1) (IdealWorld.message.Content 1);
           IdealWorld.users := $0 $+ (0,
                               {|
                               IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                               IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                               {|
                               IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                               IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                               {|
                               IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                       IdealWorld.Return
                                                         (if
                                                           match
                                                             IdealWorld.message.extractContent m2 as n
                                                             return ({1 = n} + {1 = n -> False})
                                                           with
                                                           | 0 =>
                                                               right
                                                                 (fun H : 1 = 0 =>
                                                                  match H in (_ = y1) return (y1 = 0 -> False) with
                                                                  | eq_refl =>
                                                                      fun H0 : 1 = 0 =>
                                                                      False_ind False
                                                                        (eq_ind 1
                                                                           (fun e0 : nat =>
                                                                            match e0 with
                                                                            | 0 => False
                                                                            | S _ => True
                                                                            end) I 0 H0)
                                                                  end eq_refl)
                                                           | S m =>
                                                               match
                                                                 match m as n return ({0 = n} + {0 = n -> False}) with
                                                                 | 0 => left eq_refl
                                                                 | S m0 => right (O_S m0)
                                                                 end
                                                               with
                                                               | left e0 => left (f_equal_nat nat S 0 m e0)
                                                               | right n0 => right (not_eq_S 0 m n0)
                                                               end
                                                           end
                                                          then 1
                                                          else 100))%idealworld;
                               IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
       ([e
        | exists y y0 : Map.key,
            ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
            e =
            ({|
             RealWorld.users := $0 $+ (0,
                                {|
                                RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                RealWorld.protocol := RealWorld.Return 1;
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [(Some 0, 0)];
                                RealWorld.cur_nonce := 1 |}) $+ (1,
                                {|
                                RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y0];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [(Some 1, 0)];
                                RealWorld.cur_nonce := 1 |}) $+ (2,
                                {|
                                RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                        (fun vote1 : RealWorld.message.message Nat =>
                                                         RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                           (fun vote2 : RealWorld.message.message Nat =>
                                                            RealWorld.Return
                                                              (if
                                                                RealWorld.message.extractContent vote1 ==n
                                                                RealWorld.message.extractContent vote2
                                                               then RealWorld.message.extractContent vote1
                                                               else 100)));
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y0; y];
                                RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                RealWorld.sent_nons := [];
                                RealWorld.cur_nonce := 0 |});
             RealWorld.adversary := {|
                                    RealWorld.key_heap := $0;
                                    RealWorld.protocol := RealWorld.Return tt;
                                    RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                          existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                    RealWorld.c_heap := [];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |};
             RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                      RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
             RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
            {|
            IdealWorld.channel_vector := IdealWorld.addMsg
                                           (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                              (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
            IdealWorld.users := $0 $+ (0,
                                {|
                                IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                {|
                                IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                {|
                                IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                        IdealWorld.Return
                                                          (if
                                                            match
                                                              IdealWorld.message.extractContent m2 as n
                                                              return ({1 = n} + {1 = n -> False})
                                                            with
                                                            | 0 =>
                                                                right
                                                                  (fun H : 1 = 0 =>
                                                                   match H in (_ = y1) return (y1 = 0 -> False) with
                                                                   | eq_refl =>
                                                                       fun H0 : 1 = 0 =>
                                                                       False_ind False
                                                                         (eq_ind 1
                                                                            (fun e0 : nat =>
                                                                             match e0 with
                                                                             | 0 => False
                                                                             | S _ => True
                                                                             end) I 0 H0)
                                                                   end eq_refl)
                                                            | S m =>
                                                                match
                                                                  match m as n return ({0 = n} + {0 = n -> False}) with
                                                                  | 0 => left eq_refl
                                                                  | S m0 => right (O_S m0)
                                                                  end
                                                                with
                                                                | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                | right n0 => right (not_eq_S 0 m n0)
                                                                end
                                                            end
                                                           then 1
                                                           else 100))%idealworld;
                                IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
        ([e
         | exists y y0 : Map.key,
             ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
             e =
             ({|
              RealWorld.users := $0 $+ (0,
                                 {|
                                 RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                 RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [(Some 0, 0)];
                                 RealWorld.cur_nonce := 1 |}) $+ (1,
                                 {|
                                 RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                 RealWorld.protocol := RealWorld.Return 1;
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y0];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [(Some 1, 0)];
                                 RealWorld.cur_nonce := 1 |}) $+ (2,
                                 {|
                                 RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                 RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                         (fun vote1 : RealWorld.message.message Nat =>
                                                          RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                            (fun vote2 : RealWorld.message.message Nat =>
                                                             RealWorld.Return
                                                               (if
                                                                 RealWorld.message.extractContent vote1 ==n
                                                                 RealWorld.message.extractContent vote2
                                                                then RealWorld.message.extractContent vote1
                                                                else 100)));
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y0; y];
                                 RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |});
              RealWorld.adversary := {|
                                     RealWorld.key_heap := $0;
                                     RealWorld.protocol := RealWorld.Return tt;
                                     RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                           existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                     RealWorld.c_heap := [];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |};
              RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                       RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
              RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
             {|
             IdealWorld.channel_vector := IdealWorld.addMsg
                                            (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                               (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
             IdealWorld.users := $0 $+ (0,
                                 {|
                                 IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                 IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                 {|
                                 IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                 IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                 {|
                                 IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                         IdealWorld.Return
                                                           (if
                                                             match
                                                               IdealWorld.message.extractContent m2 as n
                                                               return ({1 = n} + {1 = n -> False})
                                                             with
                                                             | 0 =>
                                                                 right
                                                                   (fun H : 1 = 0 =>
                                                                    match H in (_ = y1) return (y1 = 0 -> False) with
                                                                    | eq_refl =>
                                                                        fun H0 : 1 = 0 =>
                                                                        False_ind False
                                                                          (eq_ind 1
                                                                             (fun e0 : nat =>
                                                                              match e0 with
                                                                              | 0 => False
                                                                              | S _ => True
                                                                              end) I 0 H0)
                                                                    end eq_refl)
                                                             | S m =>
                                                                 match
                                                                   match m as n return ({0 = n} + {0 = n -> False}) with
                                                                   | 0 => left eq_refl
                                                                   | S m0 => right (O_S m0)
                                                                   end
                                                                 with
                                                                 | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                 | right n0 => right (not_eq_S 0 m n0)
                                                                 end
                                                             end
                                                            then 1
                                                            else 100))%idealworld;
                                 IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
         ([e
          | exists y y0 : Map.key,
              ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
              e =
              ({|
               RealWorld.users := $0 $+ (0,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                          (fun _ : unit => RealWorld.Return 1);
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y0];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 0, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (1,
                                  {|
                                  RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                          (fun _ : unit => RealWorld.Return 1);
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 1, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (2,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                          (fun vote1 : RealWorld.message.message Nat =>
                                                           RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                             (fun vote2 : RealWorld.message.message Nat =>
                                                              RealWorld.Return
                                                                (if
                                                                  RealWorld.message.extractContent vote1 ==n
                                                                  RealWorld.message.extractContent vote2
                                                                 then RealWorld.message.extractContent vote1
                                                                 else 100)));
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y; y0];
                                  RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                  RealWorld.sent_nons := [];
                                  RealWorld.cur_nonce := 0 |});
               RealWorld.adversary := {|
                                      RealWorld.key_heap := $0;
                                      RealWorld.protocol := RealWorld.Return tt;
                                      RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                            existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                      RealWorld.c_heap := [];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |};
               RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                        (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
               RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
              {|
              IdealWorld.channel_vector := IdealWorld.addMsg
                                             (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                                (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
              IdealWorld.users := $0 $+ (0,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                  {|
                                  IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                          IdealWorld.Return
                                                            (if
                                                              match
                                                                IdealWorld.message.extractContent m2 as n
                                                                return ({1 = n} + {1 = n -> False})
                                                              with
                                                              | 0 =>
                                                                  right
                                                                    (fun H : 1 = 0 =>
                                                                     match H in (_ = y1) return (y1 = 0 -> False) with
                                                                     | eq_refl =>
                                                                         fun H0 : 1 = 0 =>
                                                                         False_ind False
                                                                           (eq_ind 1
                                                                              (fun e0 : nat =>
                                                                               match ... with
                                                                               | ... False
                                                                               | ... True
                                                                               end) I 0 H0)
                                                                     end eq_refl)
                                                              | S m =>
                                                                  match
                                                                    match m as n return ({0 = n} + {0 = n -> False}) with
                                                                    | 0 => left eq_refl
                                                                    | S m0 => right (O_S m0)
                                                                    end
                                                                  with
                                                                  | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                  | right n0 => right (not_eq_S 0 m n0)
                                                                  end
                                                              end
                                                             then 1
                                                             else 100))%idealworld;
                                  IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
          ([e
           | exists y y0 : Map.key,
               ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
               e =
               ({|
                RealWorld.users := $0 $+ (0,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Return 1;
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 0, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (1,
                                   {|
                                   RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Return 1;
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y0];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 1, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (2,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y0))
                                                           (fun voteC2 : RealWorld.crypto Nat =>
                                                            RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                              (fun vote1 : RealWorld.message.message Nat =>
                                                               RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                 (fun vote2 : RealWorld.message.message Nat =>
                                                                  RealWorld.Return
                                                                    (if
                                                                      RealWorld.message.extractContent vote1 ==n
                                                                      RealWorld.message.extractContent vote2
                                                                     then RealWorld.message.extractContent vote1
                                                                     else 100))));
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y0; y];
                                   RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 0 |});
                RealWorld.adversary := {|
                                       RealWorld.key_heap := $0;
                                       RealWorld.protocol := RealWorld.Return tt;
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                             existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |};
                RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                         (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
               {|
               IdealWorld.channel_vector := IdealWorld.addMsg
                                              (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                 (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
               IdealWorld.users := $0 $+ (0,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                   {|
                                   IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                           IdealWorld.Return
                                                             (if
                                                               match
                                                                 IdealWorld.message.extractContent m2 as n
                                                                 return ({1 = n} + {1 = n -> False})
                                                               with
                                                               | 0 =>
                                                                   right
                                                                     (fun H : 1 = 0 =>
                                                                      match H in (_ = y1) return (y1 = 0 -> False) with
                                                                      | eq_refl =>
                                                                          fun H0 : 1 = 0 =>
                                                                          False_ind False (eq_ind 1 (... => ...) I 0 H0)
                                                                      end eq_refl)
                                                               | S m =>
                                                                   match
                                                                     match m as n return ({0 = n} + {0 = n -> False}) with
                                                                     | 0 => left eq_refl
                                                                     | S m0 => right (O_S m0)
                                                                     end
                                                                   with
                                                                   | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                   | right n0 => right (not_eq_S 0 m n0)
                                                                   end
                                                               end
                                                              then 1
                                                              else 100))%idealworld;
                                   IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
           ([e
            | exists y y0 : Map.key,
                ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                e =
                ({|
                 RealWorld.users := $0 $+ (0,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                            (fun _ : unit => RealWorld.Return 1);
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 0, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (1,
                                    {|
                                    RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Return 1;
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y0];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 1, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (2,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                            (fun vote1 : RealWorld.message.message Nat =>
                                                             RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                               (fun vote2 : RealWorld.message.message Nat =>
                                                                RealWorld.Return
                                                                  (if
                                                                    RealWorld.message.extractContent vote1 ==n
                                                                    RealWorld.message.extractContent vote2
                                                                   then RealWorld.message.extractContent vote1
                                                                   else 100)));
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y0; y];
                                    RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |});
                 RealWorld.adversary := {|
                                        RealWorld.key_heap := $0;
                                        RealWorld.protocol := RealWorld.Return tt;
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                              existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |};
                 RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                          (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                 RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                {|
                IdealWorld.channel_vector := IdealWorld.addMsg
                                               (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                  (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                IdealWorld.users := $0 $+ (0,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                    {|
                                    IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                            IdealWorld.Return
                                                              (if
                                                                match
                                                                  IdealWorld.message.extractContent m2 as n
                                                                  return ({1 = n} + {1 = n -> False})
                                                                with
                                                                | 0 =>
                                                                    right
                                                                      (fun H : 1 = 0 =>
                                                                       match H in (_ = y1) return (... -> False) with
                                                                       | eq_refl =>
                                                                           fun H0 : 1 = 0 =>
                                                                           False_ind False (eq_ind 1 ... I 0 H0)
                                                                       end eq_refl)
                                                                | S m =>
                                                                    match
                                                                      match m as n return ({...} + {...}) with
                                                                      | 0 => left eq_refl
                                                                      | S m0 => right (O_S m0)
                                                                      end
                                                                    with
                                                                    | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                    | right n0 => right (not_eq_S 0 m n0)
                                                                    end
                                                                end
                                                               then 1
                                                               else 100))%idealworld;
                                    IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
            ([e
             | exists y y0 : Map.key,
                 ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                 e =
                 ({|
                  RealWorld.users := $0 $+ (0,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Return 1;
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 0, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (1,
                                     {|
                                     RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 1, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (2,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                             (fun vote1 : RealWorld.message.message Nat =>
                                                              RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                                (fun vote2 : RealWorld.message.message Nat =>
                                                                 RealWorld.Return
                                                                   (if
                                                                     RealWorld.message.extractContent vote1 ==n
                                                                     RealWorld.message.extractContent vote2
                                                                    then RealWorld.message.extractContent vote1
                                                                    else 100)));
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0; y];
                                     RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |});
                  RealWorld.adversary := {|
                                         RealWorld.key_heap := $0;
                                         RealWorld.protocol := RealWorld.Return tt;
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                               existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |};
                  RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                           (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                  RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                 {|
                 IdealWorld.channel_vector := IdealWorld.addMsg
                                                (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                   (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                 IdealWorld.users := $0 $+ (0,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                     {|
                                     IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                             IdealWorld.Return
                                                               (if
                                                                 match
                                                                   IdealWorld.message.extractContent m2 as n
                                                                   return ({1 = n} + {1 = n -> False})
                                                                 with
                                                                 | 0 =>
                                                                     right
                                                                       (fun H : 1 = 0 =>
                                                                        match H in ... return ... with
                                                                        | eq_refl => fun ... => False_ind False ...
                                                                        end eq_refl)
                                                                 | S m =>
                                                                     match
                                                                       match m as n return ... with
                                                                       | 0 => left eq_refl
                                                                       | S m0 => right (...)
                                                                       end
                                                                     with
                                                                     | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                     | right n0 => right (not_eq_S 0 m n0)
                                                                     end
                                                                 end
                                                                then 1
                                                                else 100))%idealworld;
                                     IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
             ([e
              | exists y y0 : Map.key,
                  ((y0 = y -> False) /\ incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                  e =
                  ({|
                   RealWorld.users := $0 $+ (0,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 0, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (1,
                                      {|
                                      RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 1, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (2,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                              (fun vote1 : RealWorld.message.message Nat =>
                                                               RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                 (fun vote2 : RealWorld.message.message Nat =>
                                                                  RealWorld.Return
                                                                    (if
                                                                      RealWorld.message.extractContent vote1 ==n
                                                                      RealWorld.message.extractContent vote2
                                                                     then RealWorld.message.extractContent vote1
                                                                     else 100)));
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y; y0];
                                      RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |});
                   RealWorld.adversary := {|
                                          RealWorld.key_heap := $0;
                                          RealWorld.protocol := RealWorld.Return tt;
                                          RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |};
                   RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                            (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                   RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                  {|
                  IdealWorld.channel_vector := IdealWorld.addMsg
                                                 (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                    (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                  IdealWorld.users := $0 $+ (0,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                      {|
                                      IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                              IdealWorld.Return
                                                                (if
                                                                  match
                                                                    IdealWorld.message.extractContent m2 as n
                                                                    return ({1 = n} + {1 = n -> False})
                                                                  with
                                                                  | 0 =>
                                                                      right
                                                                        (fun H : 1 = 0 => match ... with
                                                                                          | ... ...
                                                                                          end eq_refl)
                                                                  | S m =>
                                                                      match match ... with
                                                                            | ... ...
                                                                            | ... ...
                                                                            end with
                                                                      | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                      | right n0 => right (not_eq_S 0 m n0)
                                                                      end
                                                                  end
                                                                 then 1
                                                                 else 100))%idealworld;
                                      IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
              ([e
               | exists y y0 : Map.key,
                   ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Return 1;
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 0, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Return 1;
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 1, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.SignedCiphertext y))
                                                               (fun voteC2 : RealWorld.crypto Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                                  (fun vote1 : RealWorld.message.message Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt voteC2)
                                                                     (fun vote2 : RealWorld.message.message Nat =>
                                                                      RealWorld.Return (... ... ...))));
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y; y0];
                                       RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                 existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := IdealWorld.addMsg
                                                  (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                     (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   match
                                                                     IdealWorld.message.extractContent m2 as n
                                                                     return ({...} + {...})
                                                                   with
                                                                   | 0 => right (fun ... => ... eq_refl)
                                                                   | S m =>
                                                                       match ... with
                                                                       | left e0 => left (...)
                                                                       | right n0 => right (...)
                                                                       end
                                                                   end
                                                                  then 1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y y0 : Map.key,
                    ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y0];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Return 1;
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 1, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                                (fun vote1 : RealWorld.message.message Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                   (fun vote2 : RealWorld.message.message Nat =>
                                                                    RealWorld.Return (if ... then ... else 100)));
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y; y0];
                                        RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                  existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                              (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg
                                                   (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    match ... as n return ... with
                                                                    | 0 => right (...)
                                                                    | S m => match ... with
                                                                             | ... ...
                                                                             | ... ...
                                                                             end
                                                                    end
                                                                   then 1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Return 1;
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 0, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                 (fun _ : unit => RealWorld.Return 1);
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 1, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                                 (fun vote1 : RealWorld.message.message Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                    (fun vote2 : ... => RealWorld.Return (...)));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y; y0];
                                         RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                   existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := IdealWorld.addMsg
                                                    (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                    (IdealWorld.message.Content 1);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                 IdealWorld.Return
                                                                   (if match ... with
                                                                       | ... ...
                                                                       | ... ...
                                                                       end then 1 else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y y0 : Map.key,
                      ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                  (fun ... => RealWorld.Return 1);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 0, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                  (fun _ : unit => RealWorld.Return 1);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 1, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                                  (fun vote1 : RealWorld.message.message Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt ...) (... => ...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y; y0];
                                          RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                    existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := IdealWorld.addMsg
                                                     (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                        (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                     (IdealWorld.message.Content 1);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                  IdealWorld.Return (if ... then 1 else 100))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Return 1;
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 0, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Return 1;
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 1, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y; y0];
                                           RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                        (RealWorld.SignedCiphertext y0);
                                                                     existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg
                                                      (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                         (# 0) (IdealWorld.message.Content 1)) (# 1)
                                                      (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m2 <- IdealWorld.Return (...); IdealWorld.Return (...))%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   ([e
                    | exists y y0 : Map.key,
                        ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [...];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Bind ... ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [(..., 0)];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y; y0];
                                            RealWorld.from_nons := [(..., 0); (..., 0)];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (...);
                                                                      existT RealWorld.crypto Nat (...)];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := IdealWorld.addMsg
                                                       (IdealWorld.addMsg (... #+ (# 1, [])) (# 0)
                                                          (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m2 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                    ([e
                     | exists y y0 : Map.key,
                         ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (... -> False) /\ True) /\
                         e =
                         ({|
                          RealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ...; ...; ...; ...; ...; ... |}) $+ (2,
                                             {|
                                             RealWorld.key_heap := ...;
                                             RealWorld.protocol := ...;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := ...;
                                             RealWorld.from_nons := ...;
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |});
                          RealWorld.adversary := {|
                                                 RealWorld.key_heap := $0;
                                                 RealWorld.protocol := RealWorld.Return tt;
                                                 RealWorld.msg_heap := [...; ...];
                                                 RealWorld.c_heap := [];
                                                 RealWorld.from_nons := [];
                                                 RealWorld.sent_nons := [];
                                                 RealWorld.cur_nonce := 0 |};
                          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 ... ...) $+ (y0,
                                                   RealWorld.SigEncCipher 0 3 2 (..., 0) (...));
                          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                         {|
                         IdealWorld.channel_vector := IdealWorld.addMsg (IdealWorld.addMsg ... ... ...) 
                                                        (# 1) (IdealWorld.message.Content 1);
                         IdealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ... |}) $+ (2,
                                             {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) |}, true)] \cup
                     [e
                     | exists y y0 : Map.key,
                         (incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (... -> False) /\ True) /\
                         e =
                         ({|
                          RealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ...; ...; ...; ...; ...; ... |}) $+ (2,
                                             {|
                                             RealWorld.key_heap := ...;
                                             RealWorld.protocol := ...;
                                             RealWorld.msg_heap := [];
                                             RealWorld.c_heap := ...;
                                             RealWorld.from_nons := ...;
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |});
                          RealWorld.adversary := {|
                                                 RealWorld.key_heap := $0;
                                                 RealWorld.protocol := RealWorld.Return tt;
                                                 RealWorld.msg_heap := [...; ...];
                                                 RealWorld.c_heap := [];
                                                 RealWorld.from_nons := [];
                                                 RealWorld.sent_nons := [];
                                                 RealWorld.cur_nonce := 0 |};
                          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 ... ...) $+ (y0,
                                                   RealWorld.SigEncCipher 0 3 2 (..., 0) (...));
                          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                         {|
                         IdealWorld.channel_vector := IdealWorld.addMsg (IdealWorld.addMsg ... ... ...) 
                                                        (# 1) (IdealWorld.message.Content 1);
                         IdealWorld.users := $0 $+ (0, ...) $+ (1, {| ...; ... |}) $+ (2,
                                             {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) |}, true)])))))))))))))))) \cup
     ([e
      | exists y y0 : Map.key,
          ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
          e =
          ({|
           RealWorld.users := $0 $+ (0,
                              {|
                              RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                              RealWorld.protocol := RealWorld.Return 1;
                              RealWorld.msg_heap := [];
                              RealWorld.c_heap := [y];
                              RealWorld.from_nons := [];
                              RealWorld.sent_nons := [(Some 0, 0)];
                              RealWorld.cur_nonce := 1 |}) $+ (1,
                              {|
                              RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                              RealWorld.protocol := RealWorld.Return 1;
                              RealWorld.msg_heap := [];
                              RealWorld.c_heap := [y0];
                              RealWorld.from_nons := [];
                              RealWorld.sent_nons := [(Some 1, 0)];
                              RealWorld.cur_nonce := 1 |}) $+ (2,
                              {|
                              RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                              RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                      (fun vote1 : RealWorld.message.message Nat =>
                                                       RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                         (fun vote2 : RealWorld.message.message Nat =>
                                                          RealWorld.Return
                                                            (if
                                                              RealWorld.message.extractContent vote1 ==n
                                                              RealWorld.message.extractContent vote2
                                                             then RealWorld.message.extractContent vote1
                                                             else 100)));
                              RealWorld.msg_heap := [];
                              RealWorld.c_heap := [y0; y];
                              RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                              RealWorld.sent_nons := [];
                              RealWorld.cur_nonce := 0 |});
           RealWorld.adversary := {|
                                  RealWorld.key_heap := $0;
                                  RealWorld.protocol := RealWorld.Return tt;
                                  RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                        existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                  RealWorld.c_heap := [];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [];
                                  RealWorld.cur_nonce := 0 |};
           RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                    RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
           RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
          {|
          IdealWorld.channel_vector := IdealWorld.addMsg
                                         (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                         (# 1) (IdealWorld.message.Content 1);
          IdealWorld.users := $0 $+ (0,
                              {|
                              IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                              IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                              {|
                              IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                              IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                              {|
                              IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                      IdealWorld.Return
                                                        (if
                                                          match
                                                            IdealWorld.message.extractContent m2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e0 : nat =>
                                                                           match e0 with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e0 => left (f_equal_nat nat S 0 m e0)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100))%idealworld;
                              IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
      ([e
       | exists y y0 : Map.key,
           ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
           e =
           ({|
            RealWorld.users := $0 $+ (0,
                               {|
                               RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                               RealWorld.protocol := RealWorld.Return 1;
                               RealWorld.msg_heap := [];
                               RealWorld.c_heap := [y0];
                               RealWorld.from_nons := [];
                               RealWorld.sent_nons := [(Some 0, 0)];
                               RealWorld.cur_nonce := 1 |}) $+ (1,
                               {|
                               RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                               RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                               RealWorld.msg_heap := [];
                               RealWorld.c_heap := [y];
                               RealWorld.from_nons := [];
                               RealWorld.sent_nons := [(Some 1, 0)];
                               RealWorld.cur_nonce := 1 |}) $+ (2,
                               {|
                               RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                               RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                       (fun vote1 : RealWorld.message.message Nat =>
                                                        RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                          (fun vote2 : RealWorld.message.message Nat =>
                                                           RealWorld.Return
                                                             (if
                                                               RealWorld.message.extractContent vote1 ==n
                                                               RealWorld.message.extractContent vote2
                                                              then RealWorld.message.extractContent vote1
                                                              else 100)));
                               RealWorld.msg_heap := [];
                               RealWorld.c_heap := [y; y0];
                               RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                               RealWorld.sent_nons := [];
                               RealWorld.cur_nonce := 0 |});
            RealWorld.adversary := {|
                                   RealWorld.key_heap := $0;
                                   RealWorld.protocol := RealWorld.Return tt;
                                   RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                         existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                   RealWorld.c_heap := [];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 0 |};
            RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                     RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
            RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
           {|
           IdealWorld.channel_vector := IdealWorld.addMsg
                                          (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                          (# 1) (IdealWorld.message.Content 1);
           IdealWorld.users := $0 $+ (0,
                               {|
                               IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                               IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                               {|
                               IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                               IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                               {|
                               IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                       IdealWorld.Return
                                                         (if
                                                           match
                                                             IdealWorld.message.extractContent m2 as n
                                                             return ({1 = n} + {1 = n -> False})
                                                           with
                                                           | 0 =>
                                                               right
                                                                 (fun H : 1 = 0 =>
                                                                  match H in (_ = y1) return (y1 = 0 -> False) with
                                                                  | eq_refl =>
                                                                      fun H0 : 1 = 0 =>
                                                                      False_ind False
                                                                        (eq_ind 1
                                                                           (fun e0 : nat =>
                                                                            match e0 with
                                                                            | 0 => False
                                                                            | S _ => True
                                                                            end) I 0 H0)
                                                                  end eq_refl)
                                                           | S m =>
                                                               match
                                                                 match m as n return ({0 = n} + {0 = n -> False}) with
                                                                 | 0 => left eq_refl
                                                                 | S m0 => right (O_S m0)
                                                                 end
                                                               with
                                                               | left e0 => left (f_equal_nat nat S 0 m e0)
                                                               | right n0 => right (not_eq_S 0 m n0)
                                                               end
                                                           end
                                                          then 1
                                                          else 100))%idealworld;
                               IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
       ([e
        | exists y y0 : Map.key,
            ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
            e =
            ({|
             RealWorld.users := $0 $+ (0,
                                {|
                                RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y0];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [(Some 0, 0)];
                                RealWorld.cur_nonce := 1 |}) $+ (1,
                                {|
                                RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                RealWorld.protocol := RealWorld.Return 1;
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [(Some 1, 0)];
                                RealWorld.cur_nonce := 1 |}) $+ (2,
                                {|
                                RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                        (fun vote1 : RealWorld.message.message Nat =>
                                                         RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                           (fun vote2 : RealWorld.message.message Nat =>
                                                            RealWorld.Return
                                                              (if
                                                                RealWorld.message.extractContent vote1 ==n
                                                                RealWorld.message.extractContent vote2
                                                               then RealWorld.message.extractContent vote1
                                                               else 100)));
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y; y0];
                                RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                RealWorld.sent_nons := [];
                                RealWorld.cur_nonce := 0 |});
             RealWorld.adversary := {|
                                    RealWorld.key_heap := $0;
                                    RealWorld.protocol := RealWorld.Return tt;
                                    RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                          existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                    RealWorld.c_heap := [];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |};
             RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                      RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
             RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
            {|
            IdealWorld.channel_vector := IdealWorld.addMsg
                                           (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                              (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
            IdealWorld.users := $0 $+ (0,
                                {|
                                IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                {|
                                IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                {|
                                IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                        IdealWorld.Return
                                                          (if
                                                            match
                                                              IdealWorld.message.extractContent m2 as n
                                                              return ({1 = n} + {1 = n -> False})
                                                            with
                                                            | 0 =>
                                                                right
                                                                  (fun H : 1 = 0 =>
                                                                   match H in (_ = y1) return (y1 = 0 -> False) with
                                                                   | eq_refl =>
                                                                       fun H0 : 1 = 0 =>
                                                                       False_ind False
                                                                         (eq_ind 1
                                                                            (fun e0 : nat =>
                                                                             match e0 with
                                                                             | 0 => False
                                                                             | S _ => True
                                                                             end) I 0 H0)
                                                                   end eq_refl)
                                                            | S m =>
                                                                match
                                                                  match m as n return ({0 = n} + {0 = n -> False}) with
                                                                  | 0 => left eq_refl
                                                                  | S m0 => right (O_S m0)
                                                                  end
                                                                with
                                                                | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                | right n0 => right (not_eq_S 0 m n0)
                                                                end
                                                            end
                                                           then 1
                                                           else 100))%idealworld;
                                IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
        ([e
         | exists y y0 : Map.key,
             ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
             e =
             ({|
              RealWorld.users := $0 $+ (0,
                                 {|
                                 RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                 RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y0];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [(Some 0, 0)];
                                 RealWorld.cur_nonce := 1 |}) $+ (1,
                                 {|
                                 RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                 RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [(Some 1, 0)];
                                 RealWorld.cur_nonce := 1 |}) $+ (2,
                                 {|
                                 RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                 RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                         (fun vote2 : RealWorld.message.message Nat =>
                                                          RealWorld.Return
                                                            (if
                                                              match
                                                                RealWorld.message.extractContent vote2 as n
                                                                return ({1 = n} + {1 <> n})
                                                              with
                                                              | 0 =>
                                                                  right
                                                                    (fun H : 1 = 0 =>
                                                                     match H in (_ = y1) return (y1 = 0 -> False) with
                                                                     | eq_refl =>
                                                                         fun H0 : 1 = 0 =>
                                                                         False_ind False
                                                                           (eq_ind 1
                                                                              (fun e0 : nat =>
                                                                               match ... with
                                                                               | ... => False
                                                                               | ... => True
                                                                               end) I 0 H0)
                                                                     end eq_refl)
                                                              | S m =>
                                                                  match
                                                                    match m as n return ({0 = n} + {0 <> n}) with
                                                                    | 0 => left eq_refl
                                                                    | S m0 => right (O_S m0)
                                                                    end
                                                                  with
                                                                  | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                  | right n0 => right (not_eq_S 0 m n0)
                                                                  end
                                                              end
                                                             then 1
                                                             else 100));
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y; y0];
                                 RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |});
              RealWorld.adversary := {|
                                     RealWorld.key_heap := $0;
                                     RealWorld.protocol := RealWorld.Return tt;
                                     RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                           existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                     RealWorld.c_heap := [];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |};
              RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                       RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
              RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
             {|
             IdealWorld.channel_vector := IdealWorld.addMsg
                                            (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                               (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
             IdealWorld.users := $0 $+ (0,
                                 {|
                                 IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                 IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                 {|
                                 IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                 IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                 {|
                                 IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                         IdealWorld.Return
                                                           (if
                                                             match
                                                               IdealWorld.message.extractContent m2 as n
                                                               return ({1 = n} + {1 = n -> False})
                                                             with
                                                             | 0 =>
                                                                 right
                                                                   (fun H : 1 = 0 =>
                                                                    match H in (_ = y1) return (y1 = 0 -> False) with
                                                                    | eq_refl =>
                                                                        fun H0 : 1 = 0 =>
                                                                        False_ind False
                                                                          (eq_ind 1
                                                                             (fun e0 : nat =>
                                                                              match e0 with
                                                                              | 0 => False
                                                                              | S _ => True
                                                                              end) I 0 H0)
                                                                    end eq_refl)
                                                             | S m =>
                                                                 match
                                                                   match m as n return ({0 = n} + {0 = n -> False}) with
                                                                   | 0 => left eq_refl
                                                                   | S m0 => right (O_S m0)
                                                                   end
                                                                 with
                                                                 | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                 | right n0 => right (not_eq_S 0 m n0)
                                                                 end
                                                             end
                                                            then 1
                                                            else 100))%idealworld;
                                 IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
         ([e
          | exists y y0 : Map.key,
              ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
              e =
              ({|
               RealWorld.users := $0 $+ (0,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Return 1;
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 0, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (1,
                                  {|
                                  RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Return 1;
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y0];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 1, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (2,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                          (fun vote1 : RealWorld.message.message Nat =>
                                                           RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                             (fun vote2 : RealWorld.message.message Nat =>
                                                              RealWorld.Return
                                                                (if
                                                                  RealWorld.message.extractContent vote1 ==n
                                                                  RealWorld.message.extractContent vote2
                                                                 then RealWorld.message.extractContent vote1
                                                                 else 100)));
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y0; y];
                                  RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                  RealWorld.sent_nons := [];
                                  RealWorld.cur_nonce := 0 |});
               RealWorld.adversary := {|
                                      RealWorld.key_heap := $0;
                                      RealWorld.protocol := RealWorld.Return tt;
                                      RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                            existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                      RealWorld.c_heap := [];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |};
               RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                        (y0, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
               RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
              {|
              IdealWorld.channel_vector := IdealWorld.addMsg
                                             (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
              IdealWorld.users := $0 $+ (0,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                  {|
                                  IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                          IdealWorld.Return
                                                            (if
                                                              match
                                                                IdealWorld.message.extractContent m2 as n
                                                                return ({1 = n} + {1 = n -> False})
                                                              with
                                                              | 0 =>
                                                                  right
                                                                    (fun H : 1 = 0 =>
                                                                     match H in (_ = y1) return (y1 = 0 -> False) with
                                                                     | eq_refl =>
                                                                         fun H0 : 1 = 0 =>
                                                                         False_ind False
                                                                           (eq_ind 1
                                                                              (fun e0 : nat =>
                                                                               match ... with
                                                                               | ... False
                                                                               | ... True
                                                                               end) I 0 H0)
                                                                     end eq_refl)
                                                              | S m =>
                                                                  match
                                                                    match m as n return ({0 = n} + {0 = n -> False}) with
                                                                    | 0 => left eq_refl
                                                                    | S m0 => right (O_S m0)
                                                                    end
                                                                  with
                                                                  | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                  | right n0 => right (not_eq_S 0 m n0)
                                                                  end
                                                              end
                                                             then 1
                                                             else 100))%idealworld;
                                  IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
          ([e
           | exists y y0 : Map.key,
               ((y0 = y -> False) /\ incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
               e =
               ({|
                RealWorld.users := $0 $+ (0,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                           (fun _ : unit => RealWorld.Return 1);
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y0];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 0, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (1,
                                   {|
                                   RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Return 1;
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 1, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (2,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                           (fun vote1 : RealWorld.message.message Nat =>
                                                            RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                              (fun vote2 : RealWorld.message.message Nat =>
                                                               RealWorld.Return
                                                                 (if
                                                                   RealWorld.message.extractContent vote1 ==n
                                                                   RealWorld.message.extractContent vote2
                                                                  then RealWorld.message.extractContent vote1
                                                                  else 100)));
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y; y0];
                                   RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 0 |});
                RealWorld.adversary := {|
                                       RealWorld.key_heap := $0;
                                       RealWorld.protocol := RealWorld.Return tt;
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                             existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |};
                RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                         (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
               {|
               IdealWorld.channel_vector := IdealWorld.addMsg
                                              (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                 (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
               IdealWorld.users := $0 $+ (0,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                   {|
                                   IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                           IdealWorld.Return
                                                             (if
                                                               match
                                                                 IdealWorld.message.extractContent m2 as n
                                                                 return ({1 = n} + {1 = n -> False})
                                                               with
                                                               | 0 =>
                                                                   right
                                                                     (fun H : 1 = 0 =>
                                                                      match H in (_ = y1) return (y1 = 0 -> False) with
                                                                      | eq_refl =>
                                                                          fun H0 : 1 = 0 =>
                                                                          False_ind False (eq_ind 1 (... => ...) I 0 H0)
                                                                      end eq_refl)
                                                               | S m =>
                                                                   match
                                                                     match m as n return ({0 = n} + {0 = n -> False}) with
                                                                     | 0 => left eq_refl
                                                                     | S m0 => right (O_S m0)
                                                                     end
                                                                   with
                                                                   | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                   | right n0 => right (not_eq_S 0 m n0)
                                                                   end
                                                               end
                                                              then 1
                                                              else 100))%idealworld;
                                   IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
           ([e
            | exists y y0 : Map.key,
                ((y0 = y -> False) /\ incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                e =
                ({|
                 RealWorld.users := $0 $+ (0,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Return 1;
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y0];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 0, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (1,
                                    {|
                                    RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                            (fun _ : unit => RealWorld.Return 1);
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 1, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (2,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                            (fun vote1 : RealWorld.message.message Nat =>
                                                             RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                               (fun vote2 : RealWorld.message.message Nat =>
                                                                RealWorld.Return
                                                                  (if
                                                                    RealWorld.message.extractContent vote1 ==n
                                                                    RealWorld.message.extractContent vote2
                                                                   then RealWorld.message.extractContent vote1
                                                                   else 100)));
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y; y0];
                                    RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |});
                 RealWorld.adversary := {|
                                        RealWorld.key_heap := $0;
                                        RealWorld.protocol := RealWorld.Return tt;
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                              existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |};
                 RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                          (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                 RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                {|
                IdealWorld.channel_vector := IdealWorld.addMsg
                                               (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                  (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                IdealWorld.users := $0 $+ (0,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                    {|
                                    IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                            IdealWorld.Return
                                                              (if
                                                                match
                                                                  IdealWorld.message.extractContent m2 as n
                                                                  return ({1 = n} + {1 = n -> False})
                                                                with
                                                                | 0 =>
                                                                    right
                                                                      (fun H : 1 = 0 =>
                                                                       match H in (_ = y1) return (... -> False) with
                                                                       | eq_refl =>
                                                                           fun H0 : 1 = 0 =>
                                                                           False_ind False (eq_ind 1 ... I 0 H0)
                                                                       end eq_refl)
                                                                | S m =>
                                                                    match
                                                                      match m as n return ({...} + {...}) with
                                                                      | 0 => left eq_refl
                                                                      | S m0 => right (O_S m0)
                                                                      end
                                                                    with
                                                                    | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                    | right n0 => right (not_eq_S 0 m n0)
                                                                    end
                                                                end
                                                               then 1
                                                               else 100))%idealworld;
                                    IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
            ([e
             | exists y y0 : Map.key,
                 ((y0 = y -> False) /\ incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                 e =
                 ({|
                  RealWorld.users := $0 $+ (0,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 0, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (1,
                                     {|
                                     RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                             (fun _ : unit => RealWorld.Return 1);
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 1, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (2,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                             (fun vote2 : RealWorld.message.message Nat =>
                                                              RealWorld.Return
                                                                (if
                                                                  match
                                                                    RealWorld.message.extractContent vote2 as n
                                                                    return ({1 = n} + {1 <> n})
                                                                  with
                                                                  | 0 =>
                                                                      right
                                                                        (fun H : 1 = 0 =>
                                                                         match ... ... with
                                                                         | ... => ... => ...
                                                                         end eq_refl)
                                                                  | S m =>
                                                                      match
                                                                        match ... ... with
                                                                        | ... => left eq_refl
                                                                        | ... => right ...
                                                                        end
                                                                      with
                                                                      | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                      | right n0 => right (not_eq_S 0 m n0)
                                                                      end
                                                                  end
                                                                 then 1
                                                                 else 100));
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y; y0];
                                     RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |});
                  RealWorld.adversary := {|
                                         RealWorld.key_heap := $0;
                                         RealWorld.protocol := RealWorld.Return tt;
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                               existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |};
                  RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                           (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                  RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                 {|
                 IdealWorld.channel_vector := IdealWorld.addMsg
                                                (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                   (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                 IdealWorld.users := $0 $+ (0,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                     {|
                                     IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                             IdealWorld.Return
                                                               (if
                                                                 match
                                                                   IdealWorld.message.extractContent m2 as n
                                                                   return ({1 = n} + {1 = n -> False})
                                                                 with
                                                                 | 0 =>
                                                                     right
                                                                       (fun H : 1 = 0 =>
                                                                        match H in ... return ... with
                                                                        | eq_refl => fun ... => False_ind False ...
                                                                        end eq_refl)
                                                                 | S m =>
                                                                     match
                                                                       match m as n return ... with
                                                                       | 0 => left eq_refl
                                                                       | S m0 => right (...)
                                                                       end
                                                                     with
                                                                     | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                     | right n0 => right (not_eq_S 0 m n0)
                                                                     end
                                                                 end
                                                                then 1
                                                                else 100))%idealworld;
                                     IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
             ([e
              | exists y y0 : Map.key,
                  ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                  e =
                  ({|
                   RealWorld.users := $0 $+ (0,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Return 1;
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 0, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (1,
                                      {|
                                      RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Return 1;
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 1, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (2,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                              (fun vote1 : RealWorld.message.message Nat =>
                                                               RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                 (fun vote2 : RealWorld.message.message Nat =>
                                                                  RealWorld.Return
                                                                    (if
                                                                      RealWorld.message.extractContent vote1 ==n
                                                                      RealWorld.message.extractContent vote2
                                                                     then RealWorld.message.extractContent vote1
                                                                     else 100)));
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y; y0];
                                      RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |});
                   RealWorld.adversary := {|
                                          RealWorld.key_heap := $0;
                                          RealWorld.protocol := RealWorld.Return tt;
                                          RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |};
                   RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                            (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                   RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                  {|
                  IdealWorld.channel_vector := IdealWorld.addMsg
                                                 (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                    (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                  IdealWorld.users := $0 $+ (0,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                      {|
                                      IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                              IdealWorld.Return
                                                                (if
                                                                  match
                                                                    IdealWorld.message.extractContent m2 as n
                                                                    return ({1 = n} + {1 = n -> False})
                                                                  with
                                                                  | 0 =>
                                                                      right
                                                                        (fun H : 1 = 0 => match ... with
                                                                                          | ... ...
                                                                                          end eq_refl)
                                                                  | S m =>
                                                                      match match ... with
                                                                            | ... ...
                                                                            | ... ...
                                                                            end with
                                                                      | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                      | right n0 => right (not_eq_S 0 m n0)
                                                                      end
                                                                  end
                                                                 then 1
                                                                 else 100))%idealworld;
                                      IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
              ([e
               | exists y y0 : Map.key,
                   ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                               (fun _ : unit => RealWorld.Return 1);
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 0, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Return 1;
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 1, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                               (fun vote1 : RealWorld.message.message Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                  (fun vote2 : RealWorld.message.message Nat =>
                                                                   RealWorld.Return
                                                                     (if
                                                                       RealWorld.message.extractContent vote1 ==n
                                                                       RealWorld.message.extractContent vote2
                                                                      then RealWorld.message.extractContent vote1
                                                                      else 100)));
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y; y0];
                                       RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                 existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := IdealWorld.addMsg
                                                  (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                     (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   match
                                                                     IdealWorld.message.extractContent m2 as n
                                                                     return ({...} + {...})
                                                                   with
                                                                   | 0 => right (fun ... => ... eq_refl)
                                                                   | S m =>
                                                                       match ... with
                                                                       | left e0 => left (...)
                                                                       | right n0 => right (...)
                                                                       end
                                                                   end
                                                                  then 1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y y0 : Map.key,
                    ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Return 1;
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y0];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 1, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                                (fun vote1 : RealWorld.message.message Nat =>
                                                                 RealWorld.Bind
                                                                   (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                   (fun vote2 : RealWorld.message.message Nat =>
                                                                    RealWorld.Return (if ... then ... else 100)));
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y; y0];
                                        RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                  existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                              (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg
                                                   (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    match ... as n return ... with
                                                                    | 0 => right (...)
                                                                    | S m => match ... with
                                                                             | ... ...
                                                                             | ... ...
                                                                             end
                                                                    end
                                                                   then 1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                 (fun _ : unit => RealWorld.Return 1);
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 0, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                 (fun _ : unit => RealWorld.Return 1);
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 1, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                 (fun vote2 : RealWorld.message.message Nat =>
                                                                  RealWorld.Return (if ...
                                                                                       ...
                                                                                       ...
                                                                                       end then 1 else 100));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y; y0];
                                         RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                   existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := IdealWorld.addMsg
                                                    (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 1) (IdealWorld.message.Content 1)) (# 0)
                                                    (IdealWorld.message.Content 1);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                 IdealWorld.Return
                                                                   (if match ... with
                                                                       | ... ...
                                                                       | ... ...
                                                                       end then 1 else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y y0 : Map.key,
                      ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Return 1;
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 0, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Return 1;
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 1, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind
                                                                  (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                                  (fun vote1 : RealWorld.message.message Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt ...) (... => ...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y; y0];
                                          RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                    existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := IdealWorld.addMsg
                                                     (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                        (# 0) (IdealWorld.message.Content 1)) (# 1)
                                                     (IdealWorld.message.Content 1);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                  IdealWorld.Return (if ... then 1 else 100))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       (incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Return 1;
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 0, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (... => ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 1, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y; y0];
                                           RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                        (RealWorld.SignedCiphertext y0);
                                                                     existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg
                                                      (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                         (# 0) (IdealWorld.message.Content 1)) (# 1)
                                                      (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m2 <- IdealWorld.Return (...); IdealWorld.Return (...))%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   ([e
                    | exists y y0 : Map.key,
                        (incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [...];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Return 1;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [(..., 0)];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y; y0];
                                            RealWorld.from_nons := [(..., 0); (..., 0)];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (...);
                                                                      existT RealWorld.crypto Nat (...)];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := IdealWorld.addMsg
                                                       (IdealWorld.addMsg (... #+ (# 1, [])) (# 0)
                                                          (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m2 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                    [e
                    | exists y y0 : Map.key,
                        (incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                        e =
                        ({|
                         RealWorld.users := $0 $+ (0,
                                            {|
                                            RealWorld.key_heap := ...;
                                            RealWorld.protocol := ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y0];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [...];
                                            RealWorld.cur_nonce := 1 |}) $+ (1,
                                            {|
                                            RealWorld.key_heap := ... $+ (3, false);
                                            RealWorld.protocol := RealWorld.Bind ... ...;
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [(..., 0)];
                                            RealWorld.cur_nonce := 1 |}) $+ (2,
                                            {|
                                            RealWorld.key_heap := ... $+ (1, false) $+ (3, true);
                                            RealWorld.protocol := RealWorld.Bind (...) (...);
                                            RealWorld.msg_heap := [];
                                            RealWorld.c_heap := [y; y0];
                                            RealWorld.from_nons := [(..., 0); (..., 0)];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |});
                         RealWorld.adversary := {|
                                                RealWorld.key_heap := $0;
                                                RealWorld.protocol := RealWorld.Return tt;
                                                RealWorld.msg_heap := [existT RealWorld.crypto Nat (...);
                                                                      existT RealWorld.crypto Nat (...)];
                                                RealWorld.c_heap := [];
                                                RealWorld.from_nons := [];
                                                RealWorld.sent_nons := [];
                                                RealWorld.cur_nonce := 0 |};
                         RealWorld.all_ciphers := $0 $+ (y,
                                                  RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                                  (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                         RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                        {|
                        IdealWorld.channel_vector := IdealWorld.addMsg
                                                       (IdealWorld.addMsg (... #+ (# 1, [])) (# 0)
                                                          (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
                        IdealWorld.users := $0 $+ (0, {| IdealWorld.protocol := ...%idealworld; IdealWorld.perms := ... |}) $+
                                            (1,
                                            {| IdealWorld.protocol := (...)%idealworld; IdealWorld.perms := $0 $+ (1, writer) |}) $+
                                            (2,
                                            {|
                                            IdealWorld.protocol := (m2 <- ...; ...)%idealworld;
                                            IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)]))))))))))))))))
    ([e
     | exists y y0 : Map.key,
         ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ True) /\
         e =
         ({|
          RealWorld.users := $0 $+ (0,
                             {|
                             RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Return 1;
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 0, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (1,
                             {|
                             RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                             RealWorld.protocol := RealWorld.Return 1;
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0];
                             RealWorld.from_nons := [];
                             RealWorld.sent_nons := [(Some 1, 0)];
                             RealWorld.cur_nonce := 1 |}) $+ (2,
                             {|
                             RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                             RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                     (fun vote1 : RealWorld.message.message Nat =>
                                                      RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                        (fun vote2 : RealWorld.message.message Nat =>
                                                         RealWorld.Return
                                                           (if
                                                             RealWorld.message.extractContent vote1 ==n
                                                             RealWorld.message.extractContent vote2
                                                            then RealWorld.message.extractContent vote1
                                                            else 100)));
                             RealWorld.msg_heap := [];
                             RealWorld.c_heap := [y0; y];
                             RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                             RealWorld.sent_nons := [];
                             RealWorld.cur_nonce := 0 |});
          RealWorld.adversary := {|
                                 RealWorld.key_heap := $0;
                                 RealWorld.protocol := RealWorld.Return tt;
                                 RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                       existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                 RealWorld.c_heap := [];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |};
          RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                   RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
          RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
         {|
         IdealWorld.channel_vector := IdealWorld.addMsg
                                        (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                        (# 1) (IdealWorld.message.Content 1);
         IdealWorld.users := $0 $+ (0,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                             {|
                             IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                             IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                             {|
                             IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                     IdealWorld.Return
                                                       (if
                                                         match
                                                           IdealWorld.message.extractContent m2 as n
                                                           return ({1 = n} + {1 = n -> False})
                                                         with
                                                         | 0 =>
                                                             right
                                                               (fun H : 1 = 0 =>
                                                                match H in (_ = y1) return (y1 = 0 -> False) with
                                                                | eq_refl =>
                                                                    fun H0 : 1 = 0 =>
                                                                    False_ind False
                                                                      (eq_ind 1
                                                                         (fun e0 : nat =>
                                                                          match e0 with
                                                                          | 0 => False
                                                                          | S _ => True
                                                                          end) I 0 H0)
                                                                end eq_refl)
                                                         | S m =>
                                                             match
                                                               match m as n return ({0 = n} + {0 = n -> False}) with
                                                               | 0 => left eq_refl
                                                               | S m0 => right (O_S m0)
                                                               end
                                                             with
                                                             | left e0 => left (f_equal_nat nat S 0 m e0)
                                                             | right n0 => right (not_eq_S 0 m n0)
                                                             end
                                                         end
                                                        then 1
                                                        else 100))%idealworld;
                             IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
     ([e
      | exists y y0 : Map.key,
          ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
          e =
          ({|
           RealWorld.users := $0 $+ (0,
                              {|
                              RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                              RealWorld.protocol := RealWorld.Return 1;
                              RealWorld.msg_heap := [];
                              RealWorld.c_heap := [y0];
                              RealWorld.from_nons := [];
                              RealWorld.sent_nons := [(Some 0, 0)];
                              RealWorld.cur_nonce := 1 |}) $+ (1,
                              {|
                              RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                              RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                              RealWorld.msg_heap := [];
                              RealWorld.c_heap := [y];
                              RealWorld.from_nons := [];
                              RealWorld.sent_nons := [(Some 1, 0)];
                              RealWorld.cur_nonce := 1 |}) $+ (2,
                              {|
                              RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                              RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                      (fun vote1 : RealWorld.message.message Nat =>
                                                       RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                         (fun vote2 : RealWorld.message.message Nat =>
                                                          RealWorld.Return
                                                            (if
                                                              RealWorld.message.extractContent vote1 ==n
                                                              RealWorld.message.extractContent vote2
                                                             then RealWorld.message.extractContent vote1
                                                             else 100)));
                              RealWorld.msg_heap := [];
                              RealWorld.c_heap := [y; y0];
                              RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                              RealWorld.sent_nons := [];
                              RealWorld.cur_nonce := 0 |});
           RealWorld.adversary := {|
                                  RealWorld.key_heap := $0;
                                  RealWorld.protocol := RealWorld.Return tt;
                                  RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                        existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                  RealWorld.c_heap := [];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [];
                                  RealWorld.cur_nonce := 0 |};
           RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                    RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
           RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
          {|
          IdealWorld.channel_vector := IdealWorld.addMsg
                                         (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                         (# 1) (IdealWorld.message.Content 1);
          IdealWorld.users := $0 $+ (0,
                              {|
                              IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                              IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                              {|
                              IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                              IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                              {|
                              IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                      IdealWorld.Return
                                                        (if
                                                          match
                                                            IdealWorld.message.extractContent m2 as n
                                                            return ({1 = n} + {1 = n -> False})
                                                          with
                                                          | 0 =>
                                                              right
                                                                (fun H : 1 = 0 =>
                                                                 match H in (_ = y1) return (y1 = 0 -> False) with
                                                                 | eq_refl =>
                                                                     fun H0 : 1 = 0 =>
                                                                     False_ind False
                                                                       (eq_ind 1
                                                                          (fun e0 : nat =>
                                                                           match e0 with
                                                                           | 0 => False
                                                                           | S _ => True
                                                                           end) I 0 H0)
                                                                 end eq_refl)
                                                          | S m =>
                                                              match
                                                                match m as n return ({0 = n} + {0 = n -> False}) with
                                                                | 0 => left eq_refl
                                                                | S m0 => right (O_S m0)
                                                                end
                                                              with
                                                              | left e0 => left (f_equal_nat nat S 0 m e0)
                                                              | right n0 => right (not_eq_S 0 m n0)
                                                              end
                                                          end
                                                         then 1
                                                         else 100))%idealworld;
                              IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
      ([e
       | exists y y0 : Map.key,
           ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
           e =
           ({|
            RealWorld.users := $0 $+ (0,
                               {|
                               RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                               RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                               RealWorld.msg_heap := [];
                               RealWorld.c_heap := [y0];
                               RealWorld.from_nons := [];
                               RealWorld.sent_nons := [(Some 0, 0)];
                               RealWorld.cur_nonce := 1 |}) $+ (1,
                               {|
                               RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                               RealWorld.protocol := RealWorld.Return 1;
                               RealWorld.msg_heap := [];
                               RealWorld.c_heap := [y];
                               RealWorld.from_nons := [];
                               RealWorld.sent_nons := [(Some 1, 0)];
                               RealWorld.cur_nonce := 1 |}) $+ (2,
                               {|
                               RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                               RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                       (fun vote1 : RealWorld.message.message Nat =>
                                                        RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                          (fun vote2 : RealWorld.message.message Nat =>
                                                           RealWorld.Return
                                                             (if
                                                               RealWorld.message.extractContent vote1 ==n
                                                               RealWorld.message.extractContent vote2
                                                              then RealWorld.message.extractContent vote1
                                                              else 100)));
                               RealWorld.msg_heap := [];
                               RealWorld.c_heap := [y; y0];
                               RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                               RealWorld.sent_nons := [];
                               RealWorld.cur_nonce := 0 |});
            RealWorld.adversary := {|
                                   RealWorld.key_heap := $0;
                                   RealWorld.protocol := RealWorld.Return tt;
                                   RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                         existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                   RealWorld.c_heap := [];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 0 |};
            RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                     RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
            RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
           {|
           IdealWorld.channel_vector := IdealWorld.addMsg
                                          (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0) (IdealWorld.message.Content 1))
                                          (# 1) (IdealWorld.message.Content 1);
           IdealWorld.users := $0 $+ (0,
                               {|
                               IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                               IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                               {|
                               IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                               IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                               {|
                               IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                       IdealWorld.Return
                                                         (if
                                                           match
                                                             IdealWorld.message.extractContent m2 as n
                                                             return ({1 = n} + {1 = n -> False})
                                                           with
                                                           | 0 =>
                                                               right
                                                                 (fun H : 1 = 0 =>
                                                                  match H in (_ = y1) return (y1 = 0 -> False) with
                                                                  | eq_refl =>
                                                                      fun H0 : 1 = 0 =>
                                                                      False_ind False
                                                                        (eq_ind 1
                                                                           (fun e0 : nat =>
                                                                            match e0 with
                                                                            | 0 => False
                                                                            | S _ => True
                                                                            end) I 0 H0)
                                                                  end eq_refl)
                                                           | S m =>
                                                               match
                                                                 match m as n return ({0 = n} + {0 = n -> False}) with
                                                                 | 0 => left eq_refl
                                                                 | S m0 => right (O_S m0)
                                                                 end
                                                               with
                                                               | left e0 => left (f_equal_nat nat S 0 m e0)
                                                               | right n0 => right (not_eq_S 0 m n0)
                                                               end
                                                           end
                                                          then 1
                                                          else 100))%idealworld;
                               IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
       ([e
        | exists y y0 : Map.key,
            ((y0 = y -> False) /\ incl [y0] [y0] /\ (y0 = y -> False) /\ incl [y] [y] /\ True) /\
            e =
            ({|
             RealWorld.users := $0 $+ (0,
                                {|
                                RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y0];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [(Some 0, 0)];
                                RealWorld.cur_nonce := 1 |}) $+ (1,
                                {|
                                RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (fun _ : unit => RealWorld.Return 1);
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y];
                                RealWorld.from_nons := [];
                                RealWorld.sent_nons := [(Some 1, 0)];
                                RealWorld.cur_nonce := 1 |}) $+ (2,
                                {|
                                RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                        (fun vote2 : RealWorld.message.message Nat =>
                                                         RealWorld.Return
                                                           (if
                                                             match
                                                               RealWorld.message.extractContent vote2 as n
                                                               return ({1 = n} + {1 <> n})
                                                             with
                                                             | 0 =>
                                                                 right
                                                                   (fun H : 1 = 0 =>
                                                                    match H in (_ = y1) return (y1 = 0 -> False) with
                                                                    | eq_refl =>
                                                                        fun H0 : 1 = 0 =>
                                                                        False_ind False
                                                                          (eq_ind 1
                                                                             (fun e0 : nat =>
                                                                              match e0 with
                                                                              | 0 => False
                                                                              | S _ => True
                                                                              end) I 0 H0)
                                                                    end eq_refl)
                                                             | S m =>
                                                                 match
                                                                   match m as n return ({0 = n} + {0 <> n}) with
                                                                   | 0 => left eq_refl
                                                                   | S m0 => right (O_S m0)
                                                                   end
                                                                 with
                                                                 | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                 | right n0 => right (not_eq_S 0 m n0)
                                                                 end
                                                             end
                                                            then 1
                                                            else 100));
                                RealWorld.msg_heap := [];
                                RealWorld.c_heap := [y; y0];
                                RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                RealWorld.sent_nons := [];
                                RealWorld.cur_nonce := 0 |});
             RealWorld.adversary := {|
                                    RealWorld.key_heap := $0;
                                    RealWorld.protocol := RealWorld.Return tt;
                                    RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                          existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                    RealWorld.c_heap := [];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |};
             RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y,
                                      RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
             RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
            {|
            IdealWorld.channel_vector := IdealWorld.addMsg
                                           (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 0)
                                              (IdealWorld.message.Content 1)) (# 1) (IdealWorld.message.Content 1);
            IdealWorld.users := $0 $+ (0,
                                {|
                                IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                {|
                                IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                {|
                                IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                        IdealWorld.Return
                                                          (if
                                                            match
                                                              IdealWorld.message.extractContent m2 as n
                                                              return ({1 = n} + {1 = n -> False})
                                                            with
                                                            | 0 =>
                                                                right
                                                                  (fun H : 1 = 0 =>
                                                                   match H in (_ = y1) return (y1 = 0 -> False) with
                                                                   | eq_refl =>
                                                                       fun H0 : 1 = 0 =>
                                                                       False_ind False
                                                                         (eq_ind 1
                                                                            (fun e0 : nat =>
                                                                             match e0 with
                                                                             | 0 => False
                                                                             | S _ => True
                                                                             end) I 0 H0)
                                                                   end eq_refl)
                                                            | S m =>
                                                                match
                                                                  match m as n return ({0 = n} + {0 = n -> False}) with
                                                                  | 0 => left eq_refl
                                                                  | S m0 => right (O_S m0)
                                                                  end
                                                                with
                                                                | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                | right n0 => right (not_eq_S 0 m n0)
                                                                end
                                                            end
                                                           then 1
                                                           else 100))%idealworld;
                                IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
        ([e
         | exists y y0 : Map.key,
             ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
             e =
             ({|
              RealWorld.users := $0 $+ (0,
                                 {|
                                 RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                 RealWorld.protocol := RealWorld.Return 1;
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [(Some 0, 0)];
                                 RealWorld.cur_nonce := 1 |}) $+ (1,
                                 {|
                                 RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                 RealWorld.protocol := RealWorld.Return 1;
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y0];
                                 RealWorld.from_nons := [];
                                 RealWorld.sent_nons := [(Some 1, 0)];
                                 RealWorld.cur_nonce := 1 |}) $+ (2,
                                 {|
                                 RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                 RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                         (fun vote1 : RealWorld.message.message Nat =>
                                                          RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                            (fun vote2 : RealWorld.message.message Nat =>
                                                             RealWorld.Return
                                                               (if
                                                                 RealWorld.message.extractContent vote1 ==n
                                                                 RealWorld.message.extractContent vote2
                                                                then RealWorld.message.extractContent vote1
                                                                else 100)));
                                 RealWorld.msg_heap := [];
                                 RealWorld.c_heap := [y0; y];
                                 RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                 RealWorld.sent_nons := [];
                                 RealWorld.cur_nonce := 0 |});
              RealWorld.adversary := {|
                                     RealWorld.key_heap := $0;
                                     RealWorld.protocol := RealWorld.Return tt;
                                     RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                           existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                     RealWorld.c_heap := [];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |};
              RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+ (y0,
                                       RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
              RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
             {|
             IdealWorld.channel_vector := IdealWorld.addMsg
                                            (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                               (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
             IdealWorld.users := $0 $+ (0,
                                 {|
                                 IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                 IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                 {|
                                 IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                 IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                 {|
                                 IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                         IdealWorld.Return
                                                           (if
                                                             match
                                                               IdealWorld.message.extractContent m2 as n
                                                               return ({1 = n} + {1 = n -> False})
                                                             with
                                                             | 0 =>
                                                                 right
                                                                   (fun H : 1 = 0 =>
                                                                    match H in (_ = y1) return (y1 = 0 -> False) with
                                                                    | eq_refl =>
                                                                        fun H0 : 1 = 0 =>
                                                                        False_ind False
                                                                          (eq_ind 1
                                                                             (fun e0 : nat =>
                                                                              match e0 with
                                                                              | 0 => False
                                                                              | S _ => True
                                                                              end) I 0 H0)
                                                                    end eq_refl)
                                                             | S m =>
                                                                 match
                                                                   match m as n return ({0 = n} + {0 = n -> False}) with
                                                                   | 0 => left eq_refl
                                                                   | S m0 => right (O_S m0)
                                                                   end
                                                                 with
                                                                 | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                 | right n0 => right (not_eq_S 0 m n0)
                                                                 end
                                                             end
                                                            then 1
                                                            else 100))%idealworld;
                                 IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
         ([e
          | exists y y0 : Map.key,
              ((y0 = y -> False) /\ incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
              e =
              ({|
               RealWorld.users := $0 $+ (0,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                          (fun _ : unit => RealWorld.Return 1);
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y0];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 0, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (1,
                                  {|
                                  RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                  RealWorld.protocol := RealWorld.Return 1;
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y];
                                  RealWorld.from_nons := [];
                                  RealWorld.sent_nons := [(Some 1, 0)];
                                  RealWorld.cur_nonce := 1 |}) $+ (2,
                                  {|
                                  RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                  RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                          (fun vote1 : RealWorld.message.message Nat =>
                                                           RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                             (fun vote2 : RealWorld.message.message Nat =>
                                                              RealWorld.Return
                                                                (if
                                                                  RealWorld.message.extractContent vote1 ==n
                                                                  RealWorld.message.extractContent vote2
                                                                 then RealWorld.message.extractContent vote1
                                                                 else 100)));
                                  RealWorld.msg_heap := [];
                                  RealWorld.c_heap := [y; y0];
                                  RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                  RealWorld.sent_nons := [];
                                  RealWorld.cur_nonce := 0 |});
               RealWorld.adversary := {|
                                      RealWorld.key_heap := $0;
                                      RealWorld.protocol := RealWorld.Return tt;
                                      RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                            existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                      RealWorld.c_heap := [];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |};
               RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                        (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
               RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
              {|
              IdealWorld.channel_vector := IdealWorld.addMsg
                                             (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
              IdealWorld.users := $0 $+ (0,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                  {|
                                  IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                  IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                  {|
                                  IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                          IdealWorld.Return
                                                            (if
                                                              match
                                                                IdealWorld.message.extractContent m2 as n
                                                                return ({1 = n} + {1 = n -> False})
                                                              with
                                                              | 0 =>
                                                                  right
                                                                    (fun H : 1 = 0 =>
                                                                     match H in (_ = y1) return (y1 = 0 -> False) with
                                                                     | eq_refl =>
                                                                         fun H0 : 1 = 0 =>
                                                                         False_ind False
                                                                           (eq_ind 1
                                                                              (fun e0 : nat =>
                                                                               match ... with
                                                                               | ... False
                                                                               | ... True
                                                                               end) I 0 H0)
                                                                     end eq_refl)
                                                              | S m =>
                                                                  match
                                                                    match m as n return ({0 = n} + {0 = n -> False}) with
                                                                    | 0 => left eq_refl
                                                                    | S m0 => right (O_S m0)
                                                                    end
                                                                  with
                                                                  | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                  | right n0 => right (not_eq_S 0 m n0)
                                                                  end
                                                              end
                                                             then 1
                                                             else 100))%idealworld;
                                  IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
          ([e
           | exists y y0 : Map.key,
               ((y0 = y -> False) /\ incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
               e =
               ({|
                RealWorld.users := $0 $+ (0,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Return 1;
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y0];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 0, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (1,
                                   {|
                                   RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                           (fun _ : unit => RealWorld.Return 1);
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y];
                                   RealWorld.from_nons := [];
                                   RealWorld.sent_nons := [(Some 1, 0)];
                                   RealWorld.cur_nonce := 1 |}) $+ (2,
                                   {|
                                   RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                   RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                           (fun vote1 : RealWorld.message.message Nat =>
                                                            RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                              (fun vote2 : RealWorld.message.message Nat =>
                                                               RealWorld.Return
                                                                 (if
                                                                   RealWorld.message.extractContent vote1 ==n
                                                                   RealWorld.message.extractContent vote2
                                                                  then RealWorld.message.extractContent vote1
                                                                  else 100)));
                                   RealWorld.msg_heap := [];
                                   RealWorld.c_heap := [y; y0];
                                   RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                   RealWorld.sent_nons := [];
                                   RealWorld.cur_nonce := 0 |});
                RealWorld.adversary := {|
                                       RealWorld.key_heap := $0;
                                       RealWorld.protocol := RealWorld.Return tt;
                                       RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                             existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                       RealWorld.c_heap := [];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |};
                RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                         (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
               {|
               IdealWorld.channel_vector := IdealWorld.addMsg
                                              (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                 (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
               IdealWorld.users := $0 $+ (0,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                   {|
                                   IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                   IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                   {|
                                   IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                           IdealWorld.Return
                                                             (if
                                                               match
                                                                 IdealWorld.message.extractContent m2 as n
                                                                 return ({1 = n} + {1 = n -> False})
                                                               with
                                                               | 0 =>
                                                                   right
                                                                     (fun H : 1 = 0 =>
                                                                      match H in (_ = y1) return (y1 = 0 -> False) with
                                                                      | eq_refl =>
                                                                          fun H0 : 1 = 0 =>
                                                                          False_ind False (eq_ind 1 (... => ...) I 0 H0)
                                                                      end eq_refl)
                                                               | S m =>
                                                                   match
                                                                     match m as n return ({0 = n} + {0 = n -> False}) with
                                                                     | 0 => left eq_refl
                                                                     | S m0 => right (O_S m0)
                                                                     end
                                                                   with
                                                                   | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                   | right n0 => right (not_eq_S 0 m n0)
                                                                   end
                                                               end
                                                              then 1
                                                              else 100))%idealworld;
                                   IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
           ([e
            | exists y y0 : Map.key,
                ((y0 = y -> False) /\ incl [y] [y] /\ (y0 = y -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                e =
                ({|
                 RealWorld.users := $0 $+ (0,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                            (fun _ : unit => RealWorld.Return 1);
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y0];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 0, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (1,
                                    {|
                                    RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                            (fun _ : unit => RealWorld.Return 1);
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y];
                                    RealWorld.from_nons := [];
                                    RealWorld.sent_nons := [(Some 1, 0)];
                                    RealWorld.cur_nonce := 1 |}) $+ (2,
                                    {|
                                    RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                    RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                            (fun vote2 : RealWorld.message.message Nat =>
                                                             RealWorld.Return
                                                               (if
                                                                 match
                                                                   RealWorld.message.extractContent vote2 as n
                                                                   return ({1 = n} + {1 <> n})
                                                                 with
                                                                 | 0 =>
                                                                     right
                                                                       (fun H : 1 = 0 =>
                                                                        match H in (...) return (...) with
                                                                        | eq_refl => fun H0 : ... => False_ind False (...)
                                                                        end eq_refl)
                                                                 | S m =>
                                                                     match
                                                                       match m as n return (...) with
                                                                       | 0 => left eq_refl
                                                                       | S m0 => right (O_S m0)
                                                                       end
                                                                     with
                                                                     | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                     | right n0 => right (not_eq_S 0 m n0)
                                                                     end
                                                                 end
                                                                then 1
                                                                else 100));
                                    RealWorld.msg_heap := [];
                                    RealWorld.c_heap := [y; y0];
                                    RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                    RealWorld.sent_nons := [];
                                    RealWorld.cur_nonce := 0 |});
                 RealWorld.adversary := {|
                                        RealWorld.key_heap := $0;
                                        RealWorld.protocol := RealWorld.Return tt;
                                        RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                              existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                        RealWorld.c_heap := [];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |};
                 RealWorld.all_ciphers := $0 $+ (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1)) $+
                                          (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1));
                 RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                {|
                IdealWorld.channel_vector := IdealWorld.addMsg
                                               (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                  (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                IdealWorld.users := $0 $+ (0,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                    {|
                                    IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                    IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                    {|
                                    IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                            IdealWorld.Return
                                                              (if
                                                                match
                                                                  IdealWorld.message.extractContent m2 as n
                                                                  return ({1 = n} + {1 = n -> False})
                                                                with
                                                                | 0 =>
                                                                    right
                                                                      (fun H : 1 = 0 =>
                                                                       match H in (_ = y1) return (... -> False) with
                                                                       | eq_refl =>
                                                                           fun H0 : 1 = 0 =>
                                                                           False_ind False (eq_ind 1 ... I 0 H0)
                                                                       end eq_refl)
                                                                | S m =>
                                                                    match
                                                                      match m as n return ({...} + {...}) with
                                                                      | 0 => left eq_refl
                                                                      | S m0 => right (O_S m0)
                                                                      end
                                                                    with
                                                                    | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                    | right n0 => right (not_eq_S 0 m n0)
                                                                    end
                                                                end
                                                               then 1
                                                               else 100))%idealworld;
                                    IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
            ([e
             | exists y y0 : Map.key,
                 ((y = y0 -> False) /\ incl [y] [y] /\ incl [y0] [y0] /\ (y = y0 -> False) /\ (# 1 = # 0 -> False) /\ True) /\
                 e =
                 ({|
                  RealWorld.users := $0 $+ (0,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Return 1;
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y0];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 0, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (1,
                                     {|
                                     RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                     RealWorld.protocol := RealWorld.Return 1;
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y];
                                     RealWorld.from_nons := [];
                                     RealWorld.sent_nons := [(Some 1, 0)];
                                     RealWorld.cur_nonce := 1 |}) $+ (2,
                                     {|
                                     RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                     RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                             (fun vote1 : RealWorld.message.message Nat =>
                                                              RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                (fun vote2 : RealWorld.message.message Nat =>
                                                                 RealWorld.Return
                                                                   (if
                                                                     RealWorld.message.extractContent vote1 ==n
                                                                     RealWorld.message.extractContent vote2
                                                                    then RealWorld.message.extractContent vote1
                                                                    else 100)));
                                     RealWorld.msg_heap := [];
                                     RealWorld.c_heap := [y; y0];
                                     RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                     RealWorld.sent_nons := [];
                                     RealWorld.cur_nonce := 0 |});
                  RealWorld.adversary := {|
                                         RealWorld.key_heap := $0;
                                         RealWorld.protocol := RealWorld.Return tt;
                                         RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                               existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                         RealWorld.c_heap := [];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |};
                  RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                           (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                  RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                 {|
                 IdealWorld.channel_vector := IdealWorld.addMsg
                                                (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                   (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                 IdealWorld.users := $0 $+ (0,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                     {|
                                     IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                     IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                     {|
                                     IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                             IdealWorld.Return
                                                               (if
                                                                 match
                                                                   IdealWorld.message.extractContent m2 as n
                                                                   return ({1 = n} + {1 = n -> False})
                                                                 with
                                                                 | 0 =>
                                                                     right
                                                                       (fun H : 1 = 0 =>
                                                                        match H in ... return ... with
                                                                        | eq_refl => fun ... => False_ind False ...
                                                                        end eq_refl)
                                                                 | S m =>
                                                                     match
                                                                       match m as n return ... with
                                                                       | 0 => left eq_refl
                                                                       | S m0 => right (...)
                                                                       end
                                                                     with
                                                                     | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                     | right n0 => right (not_eq_S 0 m n0)
                                                                     end
                                                                 end
                                                                then 1
                                                                else 100))%idealworld;
                                     IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
             ([e
              | exists y y0 : Map.key,
                  ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                  e =
                  ({|
                   RealWorld.users := $0 $+ (0,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                              (fun _ : unit => RealWorld.Return 1);
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y0];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 0, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (1,
                                      {|
                                      RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                      RealWorld.protocol := RealWorld.Return 1;
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y];
                                      RealWorld.from_nons := [];
                                      RealWorld.sent_nons := [(Some 1, 0)];
                                      RealWorld.cur_nonce := 1 |}) $+ (2,
                                      {|
                                      RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                      RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                              (fun vote1 : RealWorld.message.message Nat =>
                                                               RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                 (fun vote2 : RealWorld.message.message Nat =>
                                                                  RealWorld.Return
                                                                    (if
                                                                      RealWorld.message.extractContent vote1 ==n
                                                                      RealWorld.message.extractContent vote2
                                                                     then RealWorld.message.extractContent vote1
                                                                     else 100)));
                                      RealWorld.msg_heap := [];
                                      RealWorld.c_heap := [y; y0];
                                      RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                      RealWorld.sent_nons := [];
                                      RealWorld.cur_nonce := 0 |});
                   RealWorld.adversary := {|
                                          RealWorld.key_heap := $0;
                                          RealWorld.protocol := RealWorld.Return tt;
                                          RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                          RealWorld.c_heap := [];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |};
                   RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                            (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                   RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                  {|
                  IdealWorld.channel_vector := IdealWorld.addMsg
                                                 (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) (# 1)
                                                    (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                  IdealWorld.users := $0 $+ (0,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                      {|
                                      IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                      IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                      {|
                                      IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                              IdealWorld.Return
                                                                (if
                                                                  match
                                                                    IdealWorld.message.extractContent m2 as n
                                                                    return ({1 = n} + {1 = n -> False})
                                                                  with
                                                                  | 0 =>
                                                                      right
                                                                        (fun H : 1 = 0 => match ... with
                                                                                          | ... ...
                                                                                          end eq_refl)
                                                                  | S m =>
                                                                      match match ... with
                                                                            | ... ...
                                                                            | ... ...
                                                                            end with
                                                                      | left e0 => left (f_equal_nat nat S 0 m e0)
                                                                      | right n0 => right (not_eq_S 0 m n0)
                                                                      end
                                                                  end
                                                                 then 1
                                                                 else 100))%idealworld;
                                      IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
              ([e
               | exists y y0 : Map.key,
                   ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                   e =
                   ({|
                    RealWorld.users := $0 $+ (0,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Return 1;
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y0];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 0, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (1,
                                       {|
                                       RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                               (fun _ : unit => RealWorld.Return 1);
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y];
                                       RealWorld.from_nons := [];
                                       RealWorld.sent_nons := [(Some 1, 0)];
                                       RealWorld.cur_nonce := 1 |}) $+ (2,
                                       {|
                                       RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                       RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                               (fun vote1 : RealWorld.message.message Nat =>
                                                                RealWorld.Bind
                                                                  (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                  (fun vote2 : RealWorld.message.message Nat =>
                                                                   RealWorld.Return
                                                                     (if
                                                                       RealWorld.message.extractContent vote1 ==n
                                                                       RealWorld.message.extractContent vote2
                                                                      then RealWorld.message.extractContent vote1
                                                                      else 100)));
                                       RealWorld.msg_heap := [];
                                       RealWorld.c_heap := [y; y0];
                                       RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                       RealWorld.sent_nons := [];
                                       RealWorld.cur_nonce := 0 |});
                    RealWorld.adversary := {|
                                           RealWorld.key_heap := $0;
                                           RealWorld.protocol := RealWorld.Return tt;
                                           RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                 existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                           RealWorld.c_heap := [];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |};
                    RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                             (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                    RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                   {|
                   IdealWorld.channel_vector := IdealWorld.addMsg
                                                  (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                     (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                   IdealWorld.users := $0 $+ (0,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                       {|
                                       IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                       IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                       {|
                                       IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                               IdealWorld.Return
                                                                 (if
                                                                   match
                                                                     IdealWorld.message.extractContent m2 as n
                                                                     return ({...} + {...})
                                                                   with
                                                                   | 0 => right (fun ... => ... eq_refl)
                                                                   | S m =>
                                                                       match ... with
                                                                       | left e0 => left (...)
                                                                       | right n0 => right (...)
                                                                       end
                                                                   end
                                                                  then 1
                                                                  else 100))%idealworld;
                                       IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
               ([e
                | exists y y0 : Map.key,
                    ((y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ incl [y0] [y0] /\ (# 1 = # 0 -> False) /\ True) /\
                    e =
                    ({|
                     RealWorld.users := $0 $+ (0,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y0];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 0, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (1,
                                        {|
                                        RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                (fun _ : unit => RealWorld.Return 1);
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y];
                                        RealWorld.from_nons := [];
                                        RealWorld.sent_nons := [(Some 1, 0)];
                                        RealWorld.cur_nonce := 1 |}) $+ (2,
                                        {|
                                        RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                        RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                (fun vote2 : RealWorld.message.message Nat =>
                                                                 RealWorld.Return
                                                                   (if
                                                                     match ... ... with
                                                                     | ... => right ...
                                                                     | ... => ...
                                                                              ...
                                                                              ...
                                                                              end
                                                                     end
                                                                    then 1
                                                                    else 100));
                                        RealWorld.msg_heap := [];
                                        RealWorld.c_heap := [y; y0];
                                        RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                        RealWorld.sent_nons := [];
                                        RealWorld.cur_nonce := 0 |});
                     RealWorld.adversary := {|
                                            RealWorld.key_heap := $0;
                                            RealWorld.protocol := RealWorld.Return tt;
                                            RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y);
                                                                  existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0)];
                                            RealWorld.c_heap := [];
                                            RealWorld.from_nons := [];
                                            RealWorld.sent_nons := [];
                                            RealWorld.cur_nonce := 0 |};
                     RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                              (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                     RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                    {|
                    IdealWorld.channel_vector := IdealWorld.addMsg
                                                   (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                      (# 1) (IdealWorld.message.Content 1)) (# 0) (IdealWorld.message.Content 1);
                    IdealWorld.users := $0 $+ (0,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                        {|
                                        IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                        IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                        {|
                                        IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                IdealWorld.Return
                                                                  (if
                                                                    match ... as n return ... with
                                                                    | 0 => right (...)
                                                                    | S m => match ... with
                                                                             | ... ...
                                                                             | ... ...
                                                                             end
                                                                    end
                                                                   then 1
                                                                   else 100))%idealworld;
                                        IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                ([e
                 | exists y y0 : Map.key,
                     ((y = y0 -> False) /\ incl [y0] [y0] /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                     e =
                     ({|
                      RealWorld.users := $0 $+ (0,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Return 1;
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y0];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 0, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (1,
                                         {|
                                         RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                         RealWorld.protocol := RealWorld.Return 1;
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y];
                                         RealWorld.from_nons := [];
                                         RealWorld.sent_nons := [(Some 1, 0)];
                                         RealWorld.cur_nonce := 1 |}) $+ (2,
                                         {|
                                         RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                         RealWorld.protocol := RealWorld.Bind
                                                                 (RealWorld.Decrypt (RealWorld.SignedCiphertext y0))
                                                                 (fun vote1 : RealWorld.message.message Nat =>
                                                                  RealWorld.Bind
                                                                    (RealWorld.Decrypt (RealWorld.SignedCiphertext y))
                                                                    (fun vote2 : ... => RealWorld.Return (...)));
                                         RealWorld.msg_heap := [];
                                         RealWorld.c_heap := [y; y0];
                                         RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                         RealWorld.sent_nons := [];
                                         RealWorld.cur_nonce := 0 |});
                      RealWorld.adversary := {|
                                             RealWorld.key_heap := $0;
                                             RealWorld.protocol := RealWorld.Return tt;
                                             RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                   existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                             RealWorld.c_heap := [];
                                             RealWorld.from_nons := [];
                                             RealWorld.sent_nons := [];
                                             RealWorld.cur_nonce := 0 |};
                      RealWorld.all_ciphers := $0 $+ (y, RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+
                                               (y0, RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                      RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                     {|
                     IdealWorld.channel_vector := IdealWorld.addMsg
                                                    (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                       (# 0) (IdealWorld.message.Content 1)) (# 1)
                                                    (IdealWorld.message.Content 1);
                     IdealWorld.users := $0 $+ (0,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                         {|
                                         IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                         IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                         {|
                                         IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                 IdealWorld.Return
                                                                   (if match ... with
                                                                       | ... ...
                                                                       | ... ...
                                                                       end then 1 else 100))%idealworld;
                                         IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                 ([e
                  | exists y y0 : Map.key,
                      (incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                      e =
                      ({|
                       RealWorld.users := $0 $+ (0,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Return 1;
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y0];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 0, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (1,
                                          {|
                                          RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt)
                                                                  (fun _ : unit => RealWorld.Return 1);
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y];
                                          RealWorld.from_nons := [];
                                          RealWorld.sent_nons := [(Some 1, 0)];
                                          RealWorld.cur_nonce := 1 |}) $+ (2,
                                          {|
                                          RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                          RealWorld.protocol := RealWorld.Bind (RealWorld.Return (RealWorld.message.Content 1))
                                                                  (fun vote1 : RealWorld.message.message Nat =>
                                                                   RealWorld.Bind (RealWorld.Decrypt ...) (... => ...));
                                          RealWorld.msg_heap := [];
                                          RealWorld.c_heap := [y; y0];
                                          RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                          RealWorld.sent_nons := [];
                                          RealWorld.cur_nonce := 0 |});
                       RealWorld.adversary := {|
                                              RealWorld.key_heap := $0;
                                              RealWorld.protocol := RealWorld.Return tt;
                                              RealWorld.msg_heap := [existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y0);
                                                                    existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                              RealWorld.c_heap := [];
                                              RealWorld.from_nons := [];
                                              RealWorld.sent_nons := [];
                                              RealWorld.cur_nonce := 0 |};
                       RealWorld.all_ciphers := $0 $+ (y,
                                                RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                       RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                      {|
                      IdealWorld.channel_vector := IdealWorld.addMsg
                                                     (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                        (# 0) (IdealWorld.message.Content 1)) (# 1)
                                                     (IdealWorld.message.Content 1);
                      IdealWorld.users := $0 $+ (0,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                          {|
                                          IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                          IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                          {|
                                          IdealWorld.protocol := (m2 <- IdealWorld.Return (IdealWorld.message.Content 1);
                                                                  IdealWorld.Return (if ... then 1 else 100))%idealworld;
                                          IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                  ([e
                   | exists y y0 : Map.key,
                       (incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (...) (...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 0, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Return 1;
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 1, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return (...))
                                                                   (fun ... => RealWorld.Bind ... ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y; y0];
                                           RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                        (RealWorld.SignedCiphertext y0);
                                                                     existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg
                                                      (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                         (# 0) (IdealWorld.message.Content 1)) (# 1)
                                                      (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m2 <- IdealWorld.Return (...); IdealWorld.Return (...))%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)] \cup
                   [e
                   | exists y y0 : Map.key,
                       (incl [y0] [y0] /\ (y = y0 -> False) /\ incl [y] [y] /\ (y = y0 -> False) /\ True) /\
                       e =
                       ({|
                        RealWorld.users := $0 $+ (0,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (...) (...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y0];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 0, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (1,
                                           {|
                                           RealWorld.key_heap := $0 $+ (1, true) $+ (3, false);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Return tt) (... => ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y];
                                           RealWorld.from_nons := [];
                                           RealWorld.sent_nons := [(Some 1, 0)];
                                           RealWorld.cur_nonce := 1 |}) $+ (2,
                                           {|
                                           RealWorld.key_heap := $0 $+ (0, false) $+ (1, false) $+ (3, true);
                                           RealWorld.protocol := RealWorld.Bind (RealWorld.Decrypt (...))
                                                                   (fun ... => RealWorld.Return ...);
                                           RealWorld.msg_heap := [];
                                           RealWorld.c_heap := [y; y0];
                                           RealWorld.from_nons := [(Some 1, 0); (Some 0, 0)];
                                           RealWorld.sent_nons := [];
                                           RealWorld.cur_nonce := 0 |});
                        RealWorld.adversary := {|
                                               RealWorld.key_heap := $0;
                                               RealWorld.protocol := RealWorld.Return tt;
                                               RealWorld.msg_heap := [existT RealWorld.crypto Nat
                                                                        (RealWorld.SignedCiphertext y0);
                                                                     existT RealWorld.crypto Nat (RealWorld.SignedCiphertext y)];
                                               RealWorld.c_heap := [];
                                               RealWorld.from_nons := [];
                                               RealWorld.sent_nons := [];
                                               RealWorld.cur_nonce := 0 |};
                        RealWorld.all_ciphers := $0 $+ (y,
                                                 RealWorld.SigEncCipher 1 3 2 (Some 1, 0) (RealWorld.message.Content 1)) $+ (y0,
                                                 RealWorld.SigEncCipher 0 3 2 (Some 0, 0) (RealWorld.message.Content 1));
                        RealWorld.all_keys := $0 $+ (0, skey 0) $+ (1, skey 1) $+ (3, ekey 3) |},
                       {|
                       IdealWorld.channel_vector := IdealWorld.addMsg
                                                      (IdealWorld.addMsg (#0 #+ (# 0, []) #+ (# 1, [])) 
                                                         (# 0) (IdealWorld.message.Content 1)) (# 1)
                                                      (IdealWorld.message.Content 1);
                       IdealWorld.users := $0 $+ (0,
                                           {|
                                           IdealWorld.protocol := (_ <- ...; ...)%idealworld;
                                           IdealWorld.perms := $0 $+ (0, writer) |}) $+ (1,
                                           {|
                                           IdealWorld.protocol := (_ <- IdealWorld.Return tt; IdealWorld.Return 1)%idealworld;
                                           IdealWorld.perms := $0 $+ (1, writer) |}) $+ (2,
                                           {|
                                           IdealWorld.protocol := (m2 <- IdealWorld.Return (...); IdealWorld.Return (...))%idealworld;
                                           IdealWorld.perms := $0 $+ (0, reader) $+ (1, reader) |}) |}, true)])))))))))))))))
    ?invariant1






  

  (* Show Ltac Profile. *)
  (* Show Ltac Profile "churn2". *)
  
  Lemma U_good : @universe_starts_sane _ Unit b ru0.
  Proof.
    autounfold;
      unfold universe_starts_sane; simpl.
    repeat (apply conj); intros; eauto.
    - solve_perm_merges; eauto.
    - econstructor.
    - unfold AdversarySafety.keys_honest; rewrite Forall_natmap_forall; intros.
      econstructor; unfold mkrUsr; simpl.
      rewrite !findUserKeys_add_reduce, findUserKeys_empty_is_empty; eauto.
      solve_perm_merges.
    - unfold lameAdv; simpl; eauto.
  Qed.

  Lemma univ_ok_start : universe_ok ru0.
  Proof.
    autounfold; econstructor; eauto.
  Qed.

  Lemma adv_univ_ok_start : adv_universe_ok ru0.
  Proof.
    autounfold; unfold adv_universe_ok; eauto.
    unfold keys_and_permissions_good.
    pose proof (adversary_is_lame_adv_univ_ok_clauses U_good).

    intuition eauto;
      simpl in *.

    - solve_simple_maps; eauto.
    - rewrite Forall_natmap_forall; intros.
      solve_simple_maps; simpl;
        unfold permission_heap_good; intros;
          solve_simple_maps; eauto.

    - unfold user_cipher_queues_ok.
      rewrite Forall_natmap_forall; intros.
      focus_user
      ; simpl in *; econstructor; eauto.

    - unfold honest_nonces_ok, honest_user_nonces_ok, honest_nonces_ok
      ; repeat simple apply conj
      ; intros
      ; clean_map_lookups
      ; intros
      ; focus_user
      ; try contradiction; try discriminate; simpl;
        repeat (apply conj); intros; clean_map_lookups; eauto.

    - unfold honest_users_only_honest_keys; intros.
      focus_user;
        subst;
        simpl in *;
        clean_map_lookups;
        unfold mkrUsr; simpl; 
        rewrite !findUserKeys_add_reduce, findUserKeys_empty_is_empty;
        eauto;
        simpl in *;
        solve_perm_merges;
        solve_concrete_maps;
        solve_simple_maps;
        eauto.

  Qed.
  
  Lemma universe_starts_safe : universe_ok ru0 /\ adv_universe_ok ru0.
  Proof.
    repeat (simple apply conj);
      eauto using univ_ok_start, adv_univ_ok_start.
  Qed.
  

End MyProtocolSecure.
